<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OSPFN: lib/regex.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OSPFN
   &#160;<span id="projectnumber">1.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('regex_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lib/regex.c File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;strings.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="regex-gnu_8h_source.html">regex-gnu.h</a>&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for regex.c:</div>
<div class="dyncontent">
<div class="center"><img src="regex_8c__incl.png" border="0" usemap="#lib_2regex_8c" alt=""/></div>
<map name="lib_2regex_8c" id="lib_2regex_8c">
<area shape="rect" id="node7" href="regex-gnu_8h.html" title="regex&#45;gnu.h" alt="" coords="220,80,316,107"/></map>
</div>
</div>
<p><a href="regex_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionfail__stack__elt.html">fail_stack_elt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfail__stack__type.html">fail_stack_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionregister__info__type.html">register_info_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcompile__stack__elt__t.html">compile_stack_elt_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcompile__stack__type.html">compile_stack_type</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a369266c24eacffb87046522897a570d5">_GNU_SOURCE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3084488315144c5c6df29f6368c7131f">PARAMS</a>(<a class="el" href="ospfclient_8c.html#aa24f72e6a4d6a997528142211b375496">args</a>)&#160;&#160;&#160;()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6640e68e2e8afe5fa53c6899403630a8">WIDE_CHAR_SUPPORT</a>&#160;&#160;&#160;(HAVE_WCTYPE_H &amp;&amp; HAVE_WCHAR_H &amp;&amp; HAVE_BTOWC)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a84591b979e395c1ecf40f06963f89d8b">gettext</a>(msgid)&#160;&#160;&#160;(msgid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a1a0ef2e42374f90a13299cc06f437847">gettext_noop</a>(String)&#160;&#160;&#160;String</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a98d0dff0c7366f08562d8e8583df9bb9">memcmp</a>(s1, s2, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>)&#160;&#160;&#160;bcmp (s1, s2, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aed653b4838032a2c5ce8960421c8cfd7">memcpy</a>(d, <a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>)&#160;&#160;&#160;(bcopy (<a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>, d, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>), (d))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a95cf7f68f7a75751d4abd454d6add11a">SWITCH_ENUM_CAST</a>(<a class="el" href="spgrid_8c.html#a3162ada50d1df39e0f0555ea3d60dea1">x</a>)&#160;&#160;&#160;(<a class="el" href="spgrid_8c.html#a3162ada50d1df39e0f0555ea3d60dea1">x</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#adebebe79bb84190296da4c5d67e4e434">CHAR_SET_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a>(c)&#160;&#160;&#160;<a class="el" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[c]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af96ff81718c3c27b342b5958fac6cb7e">ISASCII</a>(c)&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3773b51bd1f0ba67a1d8f05923c87d4c">ISBLANK</a>(c)&#160;&#160;&#160;((c) == ' ' || (c) == '\<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>')</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a31ddd189071199427310ccde9cedfb71">ISGRAPH</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isprint (c) &amp;&amp; !isspace (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af65108a54093e5c7220dfc15f6cd9db1">ISPRINT</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isprint (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab615ddd0d086b80219cd7e0345d6b5ef">ISDIGIT</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isdigit (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a8c0056118f585fa052e0f76e3198db6a">ISALNUM</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isalnum (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#afe0bf9496b5e0ecf253fb86072ee7ecf">ISALPHA</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isalpha (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a5079e89f60f6f44944ea9dc3b59f14d5">ISCNTRL</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; iscntrl (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#acb1e7358e00baea87b36a635fdb6970f">ISLOWER</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; islower (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a165393454eb1019f3f77cedba52e23de">ISPUNCT</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; ispunct (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae8cdc17e44905c826bddf416b7bf621c">ISSPACE</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isspace (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a2bfd4177f165a5968d95960d42578ab6">ISUPPER</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isupper (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a419f06aab80b7c8eb3aaf4dd70463731">ISXDIGIT</a>(c)&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isxdigit (c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad4771ad2e5dd6a87c83ecf879b7985de">TOLOWER</a>(c)&#160;&#160;&#160;tolower(c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&#160;&#160;&#160;(void *)0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#affd804aa116f7d43493d29c6607df14d">SIGN_EXTEND_CHAR</a>(c)&#160;&#160;&#160;((((unsigned char) (c)) ^ 128) - 128)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ac0f85b18908da63fd510f189601c2a9c">REGEX_ALLOCATE</a>&#160;&#160;&#160;alloca</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3694b4c0eee68e086e659d2508cf618a">REGEX_REALLOCATE</a>(<a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, osize, nsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aea9786147160a9d7734726ed1b60a8db">REGEX_FREE</a>(arg)&#160;&#160;&#160;((void)0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a37f419167ca1f8c499ee4c899b53614b">REGEX_ALLOCATE_STACK</a>&#160;&#160;&#160;alloca</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9247bcb7e41d886eaac155949a0e58e0">REGEX_REALLOCATE_STACK</a>(<a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, osize, nsize)&#160;&#160;&#160;REGEX_REALLOCATE (<a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, osize, nsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6eea4d3debda32ae12ea46de7cf1a11f">REGEX_FREE_STACK</a>(arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a490c47f87b80eb6afdb77510567659e4">FIRST_STRING_P</a>(ptr)&#160;&#160;&#160;(size1 &amp;&amp; string1 &lt;= (ptr) &amp;&amp; (ptr) &lt;= string1 + size1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aaf77bcbd178f50762a35333d83bacd09">TALLOC</a>(<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)&#160;&#160;&#160;((<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a> *) malloc ((<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>) * sizeof (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae247cb248fa0309737dce6bdfc3a6a3d">RETALLOC</a>(addr, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)&#160;&#160;&#160;((addr) = (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a> *) realloc (addr, (<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>) * sizeof (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a12c694618416cdfd35b3eb0e7f99f7f6">RETALLOC_IF</a>(addr, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)&#160;&#160;&#160;if (addr) RETALLOC((addr), (<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>), <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>); else (addr) = TALLOC ((<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>), <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a>(<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)&#160;&#160;&#160;((<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a> *) REGEX_ALLOCATE ((<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>) * sizeof (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a>(s1, s2)&#160;&#160;&#160;((strcmp (s1, s2) == 0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(a, b)&#160;&#160;&#160;((a) &gt; (b) ? (a) : (b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a, b)&#160;&#160;&#160;((a) &lt; (b) ? (a) : (b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6878991bbaf83ac3debe1d74f4a450e1">STORE_NUMBER</a>(destination, number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aec2d0e7545b2756d65a556d3ac7cdf89">STORE_NUMBER_AND_INCR</a>(destination, number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9afddc5990335682b1958801af7e4bf3">EXTRACT_NUMBER</a>(destination, <a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a>(destination, <a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a>(e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad1f96075b21c23232c91a890025692c2">DEBUG_STATEMENT</a>(e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a>(<a class="el" href="spgrid_8c.html#a3162ada50d1df39e0f0555ea3d60dea1">x</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a>(x1, x2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a>(x1, x2, x3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aca55c7b840c46d7e72964a9ecf52310f">DEBUG_PRINT4</a>(x1, x2, x3, x4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ac9718b28cdc916b46e7f98bd4c38151e">DEBUG_PRINT_COMPILED_PATTERN</a>(<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, <a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>, e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ac98cc201be49e8dd0e1d05264e7651d7">DEBUG_PRINT_DOUBLE_STRING</a>(w, s1, sz1, s2, sz2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a53cac93056e7e4dcd77c87fd5b64ab85">REG_NOERROR_IDX</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a20c488a0672699e12eebb87f4536a2a1">REG_NOMATCH_IDX</a>&#160;&#160;&#160;(REG_NOERROR_IDX + sizeof &quot;Success&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a48ae85c8247f711c7612edf7783e857c">REG_BADPAT_IDX</a>&#160;&#160;&#160;(REG_NOMATCH_IDX + sizeof &quot;No match&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6c414c00809d9b700e9d8071c4d8b051">REG_ECOLLATE_IDX</a>&#160;&#160;&#160;(REG_BADPAT_IDX + sizeof &quot;Invalid regular expression&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#acdb862b0439091c6aba1ddb34ec74c9f">REG_ECTYPE_IDX</a>&#160;&#160;&#160;(REG_ECOLLATE_IDX + sizeof &quot;Invalid collation character&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a94bc4724ebb8f838d053f9f10fa3981a">REG_EESCAPE_IDX</a>&#160;&#160;&#160;(REG_ECTYPE_IDX + sizeof &quot;Invalid character class <a class="el" href="memory_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aacadf8be59807dfbb1e55d08c26744b9">REG_ESUBREG_IDX</a>&#160;&#160;&#160;(REG_EESCAPE_IDX + sizeof &quot;Trailing backslash&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a206525485bf45f18ebf8fd0fcab5f3cd">REG_EBRACK_IDX</a>&#160;&#160;&#160;(REG_ESUBREG_IDX + sizeof &quot;Invalid back reference&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab27649935fb8e05dd687d0d1e738697a">REG_EPAREN_IDX</a>&#160;&#160;&#160;(REG_EBRACK_IDX + sizeof &quot;Unmatched [ or [^&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae63f97c2af9852820b09ada8117982f3">REG_EBRACE_IDX</a>&#160;&#160;&#160;(REG_EPAREN_IDX + sizeof &quot;Unmatched ( or \\(&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a4d53631524c3e1f51d75b3d50f04d8ed">REG_BADBR_IDX</a>&#160;&#160;&#160;(REG_EBRACE_IDX + sizeof &quot;Unmatched \\{&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9335e944484ecf3dac6270666feaaf1f">REG_ERANGE_IDX</a>&#160;&#160;&#160;(REG_BADBR_IDX + sizeof &quot;Invalid content of \\{\\}&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af6d28ac4aa08afd5fe52f7fd43abc5bb">REG_ESPACE_IDX</a>&#160;&#160;&#160;(REG_ERANGE_IDX + sizeof &quot;Invalid range end&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#acf4d9e47a0ca86890be7bee5fc73aceb">REG_BADRPT_IDX</a>&#160;&#160;&#160;(REG_ESPACE_IDX + sizeof &quot;Memory exhausted&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a5f5131e9e883c6f787f7c1041d3d3f1a">REG_EEND_IDX</a>&#160;&#160;&#160;(REG_BADRPT_IDX + sizeof &quot;Invalid preceding regular expression&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa86dc74b96a36fc455d490601cab5529">REG_ESIZE_IDX</a>&#160;&#160;&#160;(REG_EEND_IDX + sizeof &quot;Premature end of regular expression&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7a212c67e65cef62a14bc026104b3965">REG_ERPAREN_IDX</a>&#160;&#160;&#160;(REG_ESIZE_IDX + sizeof &quot;Regular expression too big&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad211d540a618e60d26c61ae8b711a0e2">MATCH_MAY_ALLOCATE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aeac2a61705646c181c38a42de6d71b7a">INIT_FAILURE_ALLOC</a>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a222a4648230cba6a1801e51b4e2ced77">FAIL_STACK_EMPTY</a>()&#160;&#160;&#160;(fail_stack.avail == 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7218502745eb68919c81cf41be91f7e8">FAIL_STACK_PTR_EMPTY</a>()&#160;&#160;&#160;(fail_stack_ptr-&gt;avail == 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae2c89df0b8a642151867be8aaab52b44">FAIL_STACK_FULL</a>()&#160;&#160;&#160;(fail_stack.avail == fail_stack.size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a0a97c6a1ac97ed1288cb47dceabc56df">INIT_FAIL_STACK</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af9f8d0785dfac45a23d8d8fdb4df1629">RESET_FAIL_STACK</a>()&#160;&#160;&#160;REGEX_FREE_STACK (fail_stack.stack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a138c79633bb68c93b6f7b7a31989fd0c">DOUBLE_FAIL_STACK</a>(fail_stack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a78ae8e3bdec768f7fd9a75b31109fa8d">PUSH_PATTERN_OP</a>(POINTER, FAIL_STACK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a880b2917876e9b98f61d985cef56109e">PUSH_FAILURE_POINTER</a>(item)&#160;&#160;&#160;fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab92b2a4088d04570c444979b2c7f909c">PUSH_FAILURE_INT</a>(item)&#160;&#160;&#160;fail_stack.stack[fail_stack.avail++].integer = (item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad2265d63a0d1735021b318f4726920f9">PUSH_FAILURE_ELT</a>(item)&#160;&#160;&#160;fail_stack.stack[fail_stack.avail++] =  (item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#abde0e78c06d9082788a9f5f0a08140cd">POP_FAILURE_POINTER</a>()&#160;&#160;&#160;fail_stack.stack[--fail_stack.avail].pointer</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9f6a9e7cd2ec7f1a660dbdad98f7ccd3">POP_FAILURE_INT</a>()&#160;&#160;&#160;fail_stack.stack[--fail_stack.avail].integer</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3dd24cbefa49fcb9c198ead90fed08bb">POP_FAILURE_ELT</a>()&#160;&#160;&#160;fail_stack.stack[--fail_stack.avail]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#adcf501a46c37ea945270b413a48d997c">DEBUG_PUSH</a>(item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a0f6414b702d4cdb7c696daf16ff46267">DEBUG_POP</a>(item_addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a74904744b0c1f8fe8cb2bf1584da2b3b">PUSH_FAILURE_POINT</a>(pattern_place, string_place, failure_code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#acc5ecaf7b97fde5acbc377a7003496d7">NUM_REG_ITEMS</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa6fc40697161c66c2a8a7c72a9cb5e77">NUM_NONREG_ITEMS</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9c1cb14ecb36be1c3ff3c5a050ecc561">MAX_FAILURE_ITEMS</a>&#160;&#160;&#160;(5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6c2bd568049066ea7c22fadaee2c894f">NUM_FAILURE_ITEMS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3c10fb30732d92eb33b8d2d0a2817e7b">REMAINING_AVAIL_SLOTS</a>&#160;&#160;&#160;((fail_stack).size - (fail_stack).avail)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a51d78204b5e3cc240058c986103c8b8e">POP_FAILURE_POINT</a>(<a class="el" href="ripng__zebra_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>, pat, low_reg, high_reg, regstart, regend, reg_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9fbdd9b78059994c85d9f064f9fa9ec3">MATCH_NULL_UNSET_VALUE</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a>(R)&#160;&#160;&#160;((R).bits.match_null_string_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a4f6628b4b02e356efb3c4c8e6cf8eaff">IS_ACTIVE</a>(R)&#160;&#160;&#160;((R).bits.is_active)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a37aeb4969c6ded152f5be7582330e6e5">MATCHED_SOMETHING</a>(R)&#160;&#160;&#160;((R).bits.matched_something)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad4e9639db811e6b09f31ff92466b404e">EVER_MATCHED_SOMETHING</a>(R)&#160;&#160;&#160;((R).bits.ever_matched_something)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a78d7e87774e3c9ae84570f8ab88f55a5">REG_UNSET_VALUE</a>&#160;&#160;&#160;(&amp;<a class="el" href="regex_8c.html#aadf22463a9896cf91277d88f89246e43">reg_unset_dummy</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a>(e)&#160;&#160;&#160;((e) == REG_UNSET_VALUE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a>(c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a95ed173b1e65d739ab2d15cc9b738ed9">PATFETCH_RAW</a>(c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a77ae0460c3885ddc73f4544ef494e402">PATUNFETCH</a>&#160;&#160;&#160;<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>--</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a>(d)&#160;&#160;&#160;(translate ? (char) translate[(unsigned char) (d)] : (d))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a598285922e2b62b38ee46ced0ebd9388">INIT_BUF_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a>(<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a>(c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a8cfee99226a6b73952701f9de12912b9">BUF_PUSH_2</a>(c1, c2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a38ceed7188d42c689f202512a1cb76fb">BUF_PUSH_3</a>(c1, c2, c3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#acfebc9fd667ce5b7d2162f2677087e21">STORE_JUMP</a>(op, loc, to)&#160;&#160;&#160;store_op1 (op, loc, (int) ((to) - (loc) - 3))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa2aa60706e57e51cc9b54ff2c8cc38a2">STORE_JUMP2</a>(op, loc, to, arg)&#160;&#160;&#160;store_op2 (op, loc, (int) ((to) - (loc) - 3), arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a4c4a6f3c88794d7c99809e8ef5054614">INSERT_JUMP</a>(op, loc, to)&#160;&#160;&#160;insert_op1 (op, loc, (int) ((to) - (loc) - 3), b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7dd59dc7da937c9308d1e7b9331aa916">INSERT_JUMP2</a>(op, loc, to, arg)&#160;&#160;&#160;insert_op2 (op, loc, (int) ((to) - (loc) - 3), arg, b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7244ab798f58214294b580ca0bb48552">MAX_BUF_SIZE</a>&#160;&#160;&#160;(1L &lt;&lt; 16)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a17d9af8542e3c215a173f67977fb06aa">REALLOC</a>(<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, <a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>)&#160;&#160;&#160;realloc ((<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>), (<a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3ac8687e6929ebcea6fbcec3332b2fe8">EXTEND_BUFFER</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af1b3c3e22fe42152c272df6027b1bf4b">MAX_REGNUM</a>&#160;&#160;&#160;255</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a988583693c22a092825fc78426d22856">INIT_COMPILE_STACK_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7d96976a27d0138b3f189f1d1a663d68">COMPILE_STACK_EMPTY</a>&#160;&#160;&#160;(compile_stack.avail == 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7e61c2eafa31a2bc3b4942c22e803e5c">COMPILE_STACK_FULL</a>&#160;&#160;&#160;(compile_stack.avail == compile_stack.size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>&#160;&#160;&#160;(compile_stack.stack[compile_stack.avail])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a>(c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aa678aabaa579a244b2f36e8e452d977e">GET_UNSIGNED_NUMBER</a>(<a class="el" href="bgp__open_8h.html#ab4570498c4316aa5f7b4852c778b3320">num</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a060354a63e337df065f8cd869b3118f1">CHAR_CLASS_MAX_LENGTH</a>&#160;&#160;&#160;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a8b3d83f068b179782bccaca23e3b20f7">IS_CHAR_CLASS</a>(string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a>(value)&#160;&#160;&#160;return (free (compile_stack.stack), value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a>(ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7c5c8716cb01b2ad2cb50732817cbe4d">MATCHING_IN_FIRST_STRING</a>&#160;&#160;&#160;(dend == end_match_1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a>(d)&#160;&#160;&#160;((d) == (size1 ? string1 : string2) || !size2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a828f1cb8f3855b8656267c902effad75">AT_STRINGS_END</a>(d)&#160;&#160;&#160;((d) == end2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a>(d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a0bf43761ab92cb6bd95c4ebc080d2a5c">FREE_VAR</a>(var)&#160;&#160;&#160;if (var) REGEX_FREE (var); var = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a7f3f2410fe2ae0089be0a2f3005f15dd">FREE_VARIABLES</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab79c167c4cd771eeb9f88cf07c8b66c2">NO_HIGHEST_ACTIVE_REG</a>&#160;&#160;&#160;(1 &lt;&lt; BYTEWIDTH)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a508c8adae6628ee43b8498249272efb9">NO_LOWEST_ACTIVE_REG</a>&#160;&#160;&#160;(NO_HIGHEST_ACTIVE_REG + 1)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionfail__stack__elt.html">fail_stack_elt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad124700b566688232f5fb6638b679858">fail_stack_elt_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a389ceb5c54c193f7b942544f6b0fe9b0">pattern_offset_t</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> { <br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a> =  0, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9">succeed</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648">anychar</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de">duplicate</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775">endbuf</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b">on_failure_keep_string_jump</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f">push_dummy_failure</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b">wordchar</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93">notwordchar</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18">wordbeg</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac">wordend</a>, 
<br/>
&#160;&#160;<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>, 
<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab7e36af3707843f77cc5b4e831c2fa6d">malloc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3d4d6185d412b00bc3def2b58b2898cc">realloc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a74a93df5c6415ecc4c83d7497bb52a9b">init_syntax_once</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int re_match_2_internal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad21fe3ef4b1cd3a5879356dd6dc1a279">PARAMS</a> ((struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct <a class="el" href="structre__registers.html">re_registers</a> *regs, int stop))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad7a880e03677a7961ddf81cdc73e8fb4">re_set_syntax</a> (<a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> regex_compile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a14b1265b519e06f4ffc1221680e909ca">_RE_ARGS</a> ((const char *pattern, size_t size, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax, struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void store_op1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#acb7757b9bc334d1e99688ab54a22cf1e">_RE_ARGS</a> ((<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void store_op2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aabc5d51462aef5afd8dc58daabc7ae6c">_RE_ARGS</a> ((<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg1, int arg2))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void insert_op1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a0dab1e53ffa7b48a0c30b2570a8fde04">_RE_ARGS</a> ((<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg, unsigned char *end))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void insert_op2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a85ed0b079e32e0a896a188a0a2a2ece9">_RE_ARGS</a> ((<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg1, int arg2, unsigned char *end))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> at_begline_loc_p&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a105e31ac3d4f239a5d1cd77caba72a44">_RE_ARGS</a> ((const char *pattern, const char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> at_endline_loc_p&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a8394fb66b955785b3b6db5b48d8d9024">_RE_ARGS</a> ((const char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, const char *pend, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> compile_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3474ca08abb941a8e94f475348dde76c">_RE_ARGS</a> ((const char **p_ptr, const char *pend, char *translate, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax, unsigned char *b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> <br class="typebreak"/>
group_in_compile_stack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a393d07733691ef82a065f7018d7a23e9">_RE_ARGS</a> ((compile_stack_typecompile_stack, <a class="el" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a> regnum))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6a04e18fe89cacd4b8d04a474def5985">regex_compile</a> (char *pattern, size_t size, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax, struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ac119126b68c58a7c0fc1af5b119450ed">store_op1</a> (<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ab2200093505d6435c2521ff819125d0d">store_op2</a> (<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg1, int arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a6ec9fc1db02e8f3a1625ed9771f5bd92">insert_op1</a> (<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg, unsigned char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae31b1d009dfa3a2b5eca3f11ec3dee6a">insert_op2</a> (<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg1, int arg2, unsigned char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a9fcec6851521f04076e51adfa274403c">at_begline_loc_p</a> (char *pattern, char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a85a9d04db18bdf4b65ea1113400613e4">at_endline_loc_p</a> (char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, char *pend, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a28dc5088ce179431d47162481e6c6540">group_in_compile_stack</a> (<a class="el" href="structcompile__stack__type.html">compile_stack_type</a> compile_stack, <a class="el" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a> regnum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a06b0c1ae265d6791c041df0ddf6d7ff6">compile_range</a> (char **p_ptr, char *pend, RE_TRANSLATE_TYPE translate, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax, unsigned char *b) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a39979f3b79c423214dc96b34996424a8">re_compile_fastmap</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad9e4e94e6531ff0387a725491e028a41">re_set_registers</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, struct <a class="el" href="structre__registers.html">re_registers</a> *regs, unsigned num_regs, <a class="el" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a> *starts, <a class="el" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a> *ends)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#afe0743116f59f62a4d00f50a9e9a4932">re_search</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string, int size, int startpos, int range, struct <a class="el" href="structre__registers.html">re_registers</a> *regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a22058f53f03b835778e1117d7abf0bd7">re_search_2</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string1, int size1, const char *string2, int size2, int startpos, int range, struct <a class="el" href="structre__registers.html">re_registers</a> *regs, int stop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a543f20720a243ca31e0667b697de3bda">re_match</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string, int size, int pos, struct <a class="el" href="structre__registers.html">re_registers</a> *regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> <br class="typebreak"/>
group_match_null_string_p&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aeeb88cd4db21f162f7defe3ded754a1d">_RE_ARGS</a> ((unsigned char **<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> <br class="typebreak"/>
alt_match_null_string_p&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a1573e54893ddab823f7fa6702d3ed5f2">_RE_ARGS</a> ((unsigned char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int bcmp_translate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af2a3c6789600240daf5204840c139b64">_RE_ARGS</a> ((const char *s1, const char *s2, int len, char *translate))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ae4aacc367337cbfc7513b4be57808b78">re_match_2</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct <a class="el" href="structre__registers.html">re_registers</a> *regs, int stop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a3b426565d92028a1cf7113fcf41942c8">re_match_2_internal</a> (struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct <a class="el" href="structre__registers.html">re_registers</a> *regs, int stop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ac1a3adc04ca27d22992ea483708c5812">group_match_null_string_p</a> (unsigned char **<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a4d088a8cdab2f2daa400a5df18cbf594">alt_match_null_string_p</a> (unsigned char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a97ff784b1a6ed91bbc1013a3a44a05da">common_op_match_null_string_p</a> (unsigned char **<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a831fca3c806cff281a70c8757c40b134">bcmp_translate</a> (char *s1, char *s2, int len, RE_TRANSLATE_TYPE translate) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#af8f972d3f97fde09a38ee8f8e204b6c3">re_compile_pattern</a> (char *pattern, size_t <a class="el" href="isis__pdu_8h.html#a64ed70bbcb4536e2af22a1aaf5209d18">length</a>, struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a38bbfba560a12468196f72aa88486406">regcomp</a> (<a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *preg, const char *pattern, int cflags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a0298f60fae70832d70e8ec5d032472a8">regexec</a> (<a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *preg, const char *string, size_t nmatch, pmatch, int eflags) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a495ccb59d8346de24a54703f66fd517d">regerror</a> (int err, const <a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *preg, char *errbuf, size_t errbuf_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#ad94d0de532eaa4fd959b8adde4d64898">regfree</a> (<a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *preg)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a> [CHAR_SET_SIZE]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#abdc5e67bbb6a48b740a95aef2bc3f5f2">re_syntax_options</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a4a5e7ab240e155127f898d0a96c68922">re_error_msgid</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aff41b1a2e0447b7f5744746b3abb9530">re_error_msgid_idx</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#a22b8c11c82d877fbf919376da65e62ca">re_max_failures</a> = 20000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8c.html#aadf22463a9896cf91277d88f89246e43">reg_unset_dummy</a></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a369266c24eacffb87046522897a570d5"></a><!-- doxytag: member="regex.c::_GNU_SOURCE" ref="a369266c24eacffb87046522897a570d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _GNU_SOURCE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00028">28</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad6d5aaa966ca7424f7cb9bd01f2c838b"></a><!-- doxytag: member="regex.c::assert" ref="ad6d5aaa966ca7424f7cb9bd01f2c838b" args="(e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00969">969</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4ae509096aba99683d03e7731c8e1095"></a><!-- doxytag: member="regex.c::AT_STRINGS_BEG" ref="a4ae509096aba99683d03e7731c8e1095" args="(d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT_STRINGS_BEG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d</td><td>)</td>
          <td>&#160;&#160;&#160;((d) == (size1 ? string1 : string2) || !size2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03730">3730</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a828f1cb8f3855b8656267c902effad75"></a><!-- doxytag: member="regex.c::AT_STRINGS_END" ref="a828f1cb8f3855b8656267c902effad75" args="(d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT_STRINGS_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d</td><td>)</td>
          <td>&#160;&#160;&#160;((d) == end2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03731">3731</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aef73eb530578e61ff012a68faccb18d0"></a><!-- doxytag: member="regex.c::BUF_PUSH" ref="aef73eb530578e61ff012a68faccb18d0" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_PUSH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    GET_BUFFER_SPACE (1);                       \
    *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>++ = (<span class="keywordtype">unsigned</span> char) (c);                     \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01620">1620</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8cfee99226a6b73952701f9de12912b9"></a><!-- doxytag: member="regex.c::BUF_PUSH_2" ref="a8cfee99226a6b73952701f9de12912b9" args="(c1, c2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_PUSH_2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    GET_BUFFER_SPACE (2);                       \
    *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>++ = (<span class="keywordtype">unsigned</span> char) (c1);                    \
    *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>++ = (<span class="keywordtype">unsigned</span> char) (c2);                    \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01628">1628</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a38ceed7188d42c689f202512a1cb76fb"></a><!-- doxytag: member="regex.c::BUF_PUSH_3" ref="a38ceed7188d42c689f202512a1cb76fb" args="(c1, c2, c3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_PUSH_3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    GET_BUFFER_SPACE (3);                       \
    *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>++ = (<span class="keywordtype">unsigned</span> char) (c1);                    \
    *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>++ = (<span class="keywordtype">unsigned</span> char) (c2);                    \
    *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>++ = (<span class="keywordtype">unsigned</span> char) (c3);                    \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01637">1637</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad72dc64cd2c9bc3598f792dc518d03b2"></a><!-- doxytag: member="regex.c::BYTEWIDTH" ref="ad72dc64cd2c9bc3598f792dc518d03b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTEWIDTH&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00372">372</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a060354a63e337df065f8cd869b3118f1"></a><!-- doxytag: member="regex.c::CHAR_CLASS_MAX_LENGTH" ref="a060354a63e337df065f8cd869b3118f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHAR_CLASS_MAX_LENGTH&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01797">1797</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="adebebe79bb84190296da4c5d67e4e434"></a><!-- doxytag: member="regex.c::CHAR_SET_SIZE" ref="adebebe79bb84190296da4c5d67e4e434" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHAR_SET_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00172">172</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7d96976a27d0138b3f189f1d1a663d68"></a><!-- doxytag: member="regex.c::COMPILE_STACK_EMPTY" ref="a7d96976a27d0138b3f189f1d1a663d68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPILE_STACK_EMPTY&#160;&#160;&#160;(compile_stack.avail == 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01750">1750</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7e61c2eafa31a2bc3b4942c22e803e5c"></a><!-- doxytag: member="regex.c::COMPILE_STACK_FULL" ref="a7e61c2eafa31a2bc3b4942c22e803e5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPILE_STACK_FULL&#160;&#160;&#160;(compile_stack.avail == compile_stack.size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01751">1751</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3c27bf6437874eb87a6622b75d2dac32"></a><!-- doxytag: member="regex.c::COMPILE_STACK_TOP" ref="a3c27bf6437874eb87a6622b75d2dac32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPILE_STACK_TOP&#160;&#160;&#160;(compile_stack.stack[compile_stack.avail])</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01754">1754</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0f6414b702d4cdb7c696daf16ff46267"></a><!-- doxytag: member="regex.c::DEBUG_POP" ref="a0f6414b702d4cdb7c696daf16ff46267" args="(item_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_POP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item_addr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01295">1295</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a90a312923984a45f83767acea95b84a1"></a><!-- doxytag: member="regex.c::DEBUG_PRINT1" ref="a90a312923984a45f83767acea95b84a1" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PRINT1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a3162ada50d1df39e0f0555ea3d60dea1">x</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00972">972</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa56b1ff14ec552b5af8e9af50bc9d5cc"></a><!-- doxytag: member="regex.c::DEBUG_PRINT2" ref="aa56b1ff14ec552b5af8e9af50bc9d5cc" args="(x1, x2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PRINT2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00973">973</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae1a07ee1a4b73aa71754bce23d0690aa"></a><!-- doxytag: member="regex.c::DEBUG_PRINT3" ref="ae1a07ee1a4b73aa71754bce23d0690aa" args="(x1, x2, x3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PRINT3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00974">974</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aca55c7b840c46d7e72964a9ecf52310f"></a><!-- doxytag: member="regex.c::DEBUG_PRINT4" ref="aca55c7b840c46d7e72964a9ecf52310f" args="(x1, x2, x3, x4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PRINT4</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x4&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00975">975</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac9718b28cdc916b46e7f98bd4c38151e"></a><!-- doxytag: member="regex.c::DEBUG_PRINT_COMPILED_PATTERN" ref="ac9718b28cdc916b46e7f98bd4c38151e" args="(p, s, e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PRINT_COMPILED_PATTERN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00976">976</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac98cc201be49e8dd0e1d05264e7651d7"></a><!-- doxytag: member="regex.c::DEBUG_PRINT_DOUBLE_STRING" ref="ac98cc201be49e8dd0e1d05264e7651d7" args="(w, s1, sz1, s2, sz2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PRINT_DOUBLE_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sz1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sz2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00977">977</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="adcf501a46c37ea945270b413a48d997c"></a><!-- doxytag: member="regex.c::DEBUG_PUSH" ref="adcf501a46c37ea945270b413a48d997c" args="(item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PUSH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01294">1294</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad1f96075b21c23232c91a890025692c2"></a><!-- doxytag: member="regex.c::DEBUG_STATEMENT" ref="ad1f96075b21c23232c91a890025692c2" args="(e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_STATEMENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00971">971</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a138c79633bb68c93b6f7b7a31989fd0c"></a><!-- doxytag: member="regex.c::DOUBLE_FAIL_STACK" ref="a138c79633bb68c93b6f7b7a31989fd0c" args="(fail_stack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOUBLE_FAIL_STACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fail_stack</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((fail_stack).size &gt; (<span class="keywordtype">unsigned</span>) (<a class="code" href="regex_8c.html#a22b8c11c82d877fbf919376da65e62ca">re_max_failures</a> * <a class="code" href="regex_8c.html#a9c1cb14ecb36be1c3ff3c5a050ecc561">MAX_FAILURE_ITEMS</a>)   \
   ? 0                                  \
   : ((fail_stack).stack = (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *)             \
        <a class="code" href="regex_8c.html#a9247bcb7e41d886eaac155949a0e58e0">REGEX_REALLOCATE_STACK</a> ((fail_stack).stack,             \
          (fail_stack).size * <span class="keyword">sizeof</span> (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a>),        \
          ((fail_stack).size &lt;&lt; 1) * <span class="keyword">sizeof</span> (<a class="code" href="regex_8c.html#ad124700b566688232f5fb6638b679858">fail_stack_elt_t</a>)),    \
                                    \
      (fail_stack).stack == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>                    \
      ? 0                               \
      : ((fail_stack).size &lt;&lt;= 1,                   \
         1)))
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01241">1241</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad4e9639db811e6b09f31ff92466b404e"></a><!-- doxytag: member="regex.c::EVER_MATCHED_SOMETHING" ref="ad4e9639db811e6b09f31ff92466b404e" args="(R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVER_MATCHED_SOMETHING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R</td><td>)</td>
          <td>&#160;&#160;&#160;((R).bits.ever_matched_something)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01526">1526</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3ac8687e6929ebcea6fbcec3332b2fe8"></a><!-- doxytag: member="regex.c::EXTEND_BUFFER" ref="a3ac8687e6929ebcea6fbcec3332b2fe8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXTEND_BUFFER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    unsigned <span class="keywordtype">char</span> *old_buffer = bufp-&gt;buffer;               \
    if (bufp-&gt;allocated == <a class="code" href="regex_8c.html#a7244ab798f58214294b580ca0bb48552">MAX_BUF_SIZE</a>)                \
      return <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea3b6ca384023fd0493140206a989bd544">REG_ESIZE</a>;                         \
    bufp-&gt;allocated &lt;&lt;= 1;                      \
    if (bufp-&gt;allocated &gt; <a class="code" href="regex_8c.html#a7244ab798f58214294b580ca0bb48552">MAX_BUF_SIZE</a>)                 \
      bufp-&gt;allocated = <a class="code" href="regex_8c.html#a7244ab798f58214294b580ca0bb48552">MAX_BUF_SIZE</a>;                   \
    bufp-&gt;buffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) <a class="code" href="regex_8c.html#a17d9af8542e3c215a173f67977fb06aa">REALLOC</a> (bufp-&gt;buffer, bufp-&gt;allocated);\
    if (bufp-&gt;buffer == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)                       \
      return <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaabf0128b7050c81c0fb933ea7265ebe9">REG_ESPACE</a>;                        \
    <span class="comment">/* If the buffer moved, move all the pointers into it.  */</span>      \
    if (old_buffer != bufp-&gt;buffer)                 \
      {                                 \
        b = (<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a> - old_buffer) + bufp-&gt;buffer;                \
        begalt = (begalt - old_buffer) + bufp-&gt;buffer;          \
        if (fixup_alt_jump)                     \
          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp-&gt;buffer;\
        if (laststart)                          \
          laststart = (laststart - old_buffer) + bufp-&gt;buffer;      \
        if (pending_exact)                      \
          pending_exact = (pending_exact - old_buffer) + bufp-&gt;buffer;  \
      }                                 \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01687">1687</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9afddc5990335682b1958801af7e4bf3"></a><!-- doxytag: member="regex.c::EXTRACT_NUMBER" ref="a9afddc5990335682b1958801af7e4bf3" args="(destination, source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXTRACT_NUMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    (destination) = *(<a class="code" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>) &amp; 0377;                   \
    (destination) += <a class="code" href="regex_8c.html#affd804aa116f7d43493d29c6607df14d">SIGN_EXTEND_CHAR</a> (*((<a class="code" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>) + 1)) &lt;&lt; 8;       \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l00554">554</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="abf958c753956f073a33bd336660e9038"></a><!-- doxytag: member="regex.c::EXTRACT_NUMBER_AND_INCR" ref="abf958c753956f073a33bd336660e9038" args="(destination, source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXTRACT_NUMBER_AND_INCR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    EXTRACT_NUMBER (destination, <a class="code" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>);               \
    (<a class="code" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>) += 2;                          \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l00582">582</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a222a4648230cba6a1801e51b4e2ced77"></a><!-- doxytag: member="regex.c::FAIL_STACK_EMPTY" ref="a222a4648230cba6a1801e51b4e2ced77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FAIL_STACK_EMPTY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(fail_stack.avail == 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01202">1202</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae2c89df0b8a642151867be8aaab52b44"></a><!-- doxytag: member="regex.c::FAIL_STACK_FULL" ref="ae2c89df0b8a642151867be8aaab52b44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FAIL_STACK_FULL</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(fail_stack.avail == fail_stack.size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01204">1204</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7218502745eb68919c81cf41be91f7e8"></a><!-- doxytag: member="regex.c::FAIL_STACK_PTR_EMPTY" ref="a7218502745eb68919c81cf41be91f7e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FAIL_STACK_PTR_EMPTY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(fail_stack_ptr-&gt;avail == 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01203">1203</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a65e9886d74aaee76545e83dd09011727"></a><!-- doxytag: member="regex.c::false" ref="a65e9886d74aaee76545e83dd09011727" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define false&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00382">382</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a490c47f87b80eb6afdb77510567659e4"></a><!-- doxytag: member="regex.c::FIRST_STRING_P" ref="a490c47f87b80eb6afdb77510567659e4" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIRST_STRING_P</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;(size1 &amp;&amp; string1 &lt;= (ptr) &amp;&amp; (ptr) &lt;= string1 + size1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00362">362</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a90d3a551feb495f25eaf3e22933dd1d7"></a><!-- doxytag: member="regex.c::FREE_STACK_RETURN" ref="a90d3a551feb495f25eaf3e22933dd1d7" args="(value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FREE_STACK_RETURN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value</td><td>)</td>
          <td>&#160;&#160;&#160;return (free (compile_stack.stack), value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01879">1879</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0bf43761ab92cb6bd95c4ebc080d2a5c"></a><!-- doxytag: member="regex.c::FREE_VAR" ref="a0bf43761ab92cb6bd95c4ebc080d2a5c" args="(var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FREE_VAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var</td><td>)</td>
          <td>&#160;&#160;&#160;if (var) REGEX_FREE (var); var = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03754">3754</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7f3f2410fe2ae0089be0a2f3005f15dd"></a><!-- doxytag: member="regex.c::FREE_VARIABLES" ref="a7f3f2410fe2ae0089be0a2f3005f15dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FREE_VARIABLES</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    REGEX_FREE_STACK (fail_stack.stack);                \
    FREE_VAR (regstart);                        \
    FREE_VAR (regend);                          \
    FREE_VAR (old_regstart);                        \
    FREE_VAR (old_regend);                      \
    FREE_VAR (best_regstart);                       \
    FREE_VAR (best_regend);                     \
    FREE_VAR (reg_info);                        \
    FREE_VAR (reg_dummy);                       \
    FREE_VAR (reg_info_dummy);                      \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l03755">3755</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a820795fca6e5960dd9657eda06c66ed5"></a><!-- doxytag: member="regex.c::GET_BUFFER_SPACE" ref="a820795fca6e5960dd9657eda06c66ed5" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BUFFER_SPACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">while</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (b - bufp-&gt;buffer + (<a class="code" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>)) &gt; bufp-&gt;allocated)  \
      EXTEND_BUFFER ()
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01615">1615</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa678aabaa579a244b2f36e8e452d977e"></a><!-- doxytag: member="regex.c::GET_UNSIGNED_NUMBER" ref="aa678aabaa579a244b2f36e8e452d977e" args="(num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_UNSIGNED_NUMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="bgp__open_8h.html#ab4570498c4316aa5f7b4852c778b3320">num</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ <span class="keywordflow">if</span> (<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> != pend)                            \
     {                                  \
       PATFETCH (c);                            \
       while (<a class="code" href="regex_8c.html#ab615ddd0d086b80219cd7e0345d6b5ef">ISDIGIT</a> (c))                      \
         {                              \
           if (<a class="code" href="bgp__open_8h.html#ab4570498c4316aa5f7b4852c778b3320">num</a> &lt; 0)                         \
              num = 0;                          \
           num = <a class="code" href="bgp__open_8h.html#ab4570498c4316aa5f7b4852c778b3320">num</a> * 10 + c - <span class="charliteral">&#39;0&#39;</span>;                    \
           if (<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> == pend)                       \
              break;                            \
           PATFETCH (c);                        \
         }                              \
       }                                \
    }
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01764">1764</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a84591b979e395c1ecf40f06963f89d8b"></a><!-- doxytag: member="regex.c::gettext" ref="a84591b979e395c1ecf40f06963f89d8b" args="(msgid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define gettext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msgid</td><td>)</td>
          <td>&#160;&#160;&#160;(msgid)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00092">92</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1a0ef2e42374f90a13299cc06f437847"></a><!-- doxytag: member="regex.c::gettext_noop" ref="a1a0ef2e42374f90a13299cc06f437847" args="(String)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define gettext_noop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">String</td><td>)</td>
          <td>&#160;&#160;&#160;String</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00098">98</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a598285922e2b62b38ee46ced0ebd9388"></a><!-- doxytag: member="regex.c::INIT_BUF_SIZE" ref="a598285922e2b62b38ee46ced0ebd9388" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INIT_BUF_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01612">1612</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a988583693c22a092825fc78426d22856"></a><!-- doxytag: member="regex.c::INIT_COMPILE_STACK_SIZE" ref="a988583693c22a092825fc78426d22856" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INIT_COMPILE_STACK_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01748">1748</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0a97c6a1ac97ed1288cb47dceabc56df"></a><!-- doxytag: member="regex.c::INIT_FAIL_STACK" ref="a0a97c6a1ac97ed1288cb47dceabc56df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INIT_FAIL_STACK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    fail_stack.stack = (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *)             \
      <a class="code" href="regex_8c.html#a37f419167ca1f8c499ee4c899b53614b">REGEX_ALLOCATE_STACK</a> (<a class="code" href="regex_8c.html#aeac2a61705646c181c38a42de6d71b7a">INIT_FAILURE_ALLOC</a> * <span class="keyword">sizeof</span> (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a>)); \
                                    \
    if (fail_stack.stack == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)                   \
      return -2;                            \
                                    \
    fail_stack.size = <a class="code" href="regex_8c.html#aeac2a61705646c181c38a42de6d71b7a">INIT_FAILURE_ALLOC</a>;               \
    fail_stack.avail = 0;                       \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01211">1211</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aeac2a61705646c181c38a42de6d71b7a"></a><!-- doxytag: member="regex.c::INIT_FAILURE_ALLOC" ref="aeac2a61705646c181c38a42de6d71b7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INIT_FAILURE_ALLOC&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01142">1142</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4c4a6f3c88794d7c99809e8ef5054614"></a><!-- doxytag: member="regex.c::INSERT_JUMP" ref="a4c4a6f3c88794d7c99809e8ef5054614" args="(op, loc, to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSERT_JUMP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">loc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">to&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;insert_op1 (op, loc, (int) ((to) - (loc) - 3), b)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01656">1656</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7dd59dc7da937c9308d1e7b9331aa916"></a><!-- doxytag: member="regex.c::INSERT_JUMP2" ref="a7dd59dc7da937c9308d1e7b9331aa916" args="(op, loc, to, arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSERT_JUMP2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">loc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">to, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;insert_op2 (op, loc, (int) ((to) - (loc) - 3), arg, b)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01660">1660</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4f6628b4b02e356efb3c4c8e6cf8eaff"></a><!-- doxytag: member="regex.c::IS_ACTIVE" ref="a4f6628b4b02e356efb3c4c8e6cf8eaff" args="(R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_ACTIVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R</td><td>)</td>
          <td>&#160;&#160;&#160;((R).bits.is_active)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01524">1524</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8b3d83f068b179782bccaca23e3b20f7"></a><!-- doxytag: member="regex.c::IS_CHAR_CLASS" ref="a8b3d83f068b179782bccaca23e3b20f7" args="(string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_CHAR_CLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">string</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;alpha&quot;</span>) || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;upper&quot;</span>)         \
    || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;lower&quot;</span>) || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;digit&quot;</span>)       \
    || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;alnum&quot;</span>) || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;xdigit&quot;</span>)      \
    || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;space&quot;</span>) || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;print&quot;</span>)       \
    || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;punct&quot;</span>) || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;graph&quot;</span>)       \
    || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;cntrl&quot;</span>) || <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;blank&quot;</span>))
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01799">1799</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0056118f585fa052e0f76e3198db6a"></a><!-- doxytag: member="regex.c::ISALNUM" ref="a8c0056118f585fa052e0f76e3198db6a" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISALNUM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isalnum (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00252">252</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="afe0bf9496b5e0ecf253fb86072ee7ecf"></a><!-- doxytag: member="regex.c::ISALPHA" ref="afe0bf9496b5e0ecf253fb86072ee7ecf" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISALPHA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isalpha (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00253">253</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="af96ff81718c3c27b342b5958fac6cb7e"></a><!-- doxytag: member="regex.c::ISASCII" ref="af96ff81718c3c27b342b5958fac6cb7e" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISASCII</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00233">233</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3773b51bd1f0ba67a1d8f05923c87d4c"></a><!-- doxytag: member="regex.c::ISBLANK" ref="a3773b51bd1f0ba67a1d8f05923c87d4c" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISBLANK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;((c) == ' ' || (c) == '\<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>')</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00241">241</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5079e89f60f6f44944ea9dc3b59f14d5"></a><!-- doxytag: member="regex.c::ISCNTRL" ref="a5079e89f60f6f44944ea9dc3b59f14d5" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISCNTRL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; iscntrl (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00254">254</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab615ddd0d086b80219cd7e0345d6b5ef"></a><!-- doxytag: member="regex.c::ISDIGIT" ref="ab615ddd0d086b80219cd7e0345d6b5ef" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISDIGIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isdigit (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00251">251</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a31ddd189071199427310ccde9cedfb71"></a><!-- doxytag: member="regex.c::ISGRAPH" ref="a31ddd189071199427310ccde9cedfb71" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISGRAPH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isprint (c) &amp;&amp; !isspace (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00246">246</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="acb1e7358e00baea87b36a635fdb6970f"></a><!-- doxytag: member="regex.c::ISLOWER" ref="acb1e7358e00baea87b36a635fdb6970f" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISLOWER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; islower (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00255">255</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="af65108a54093e5c7220dfc15f6cd9db1"></a><!-- doxytag: member="regex.c::ISPRINT" ref="af65108a54093e5c7220dfc15f6cd9db1" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISPRINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isprint (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00250">250</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a165393454eb1019f3f77cedba52e23de"></a><!-- doxytag: member="regex.c::ISPUNCT" ref="a165393454eb1019f3f77cedba52e23de" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISPUNCT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; ispunct (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00256">256</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae8cdc17e44905c826bddf416b7bf621c"></a><!-- doxytag: member="regex.c::ISSPACE" ref="ae8cdc17e44905c826bddf416b7bf621c" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISSPACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isspace (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00257">257</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2bfd4177f165a5968d95960d42578ab6"></a><!-- doxytag: member="regex.c::ISUPPER" ref="a2bfd4177f165a5968d95960d42578ab6" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISUPPER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isupper (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00258">258</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a419f06aab80b7c8eb3aaf4dd70463731"></a><!-- doxytag: member="regex.c::ISXDIGIT" ref="a419f06aab80b7c8eb3aaf4dd70463731" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISXDIGIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;(ISASCII (c) &amp;&amp; isxdigit (c))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00259">259</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad211d540a618e60d26c61ae8b711a0e2"></a><!-- doxytag: member="regex.c::MATCH_MAY_ALLOCATE" ref="ad211d540a618e60d26c61ae8b711a0e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCH_MAY_ALLOCATE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01115">1115</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9fbdd9b78059994c85d9f064f9fa9ec3"></a><!-- doxytag: member="regex.c::MATCH_NULL_UNSET_VALUE" ref="a9fbdd9b78059994c85d9f064f9fa9ec3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCH_NULL_UNSET_VALUE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01515">1515</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a37aeb4969c6ded152f5be7582330e6e5"></a><!-- doxytag: member="regex.c::MATCHED_SOMETHING" ref="a37aeb4969c6ded152f5be7582330e6e5" args="(R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCHED_SOMETHING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R</td><td>)</td>
          <td>&#160;&#160;&#160;((R).bits.matched_something)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01525">1525</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5c8716cb01b2ad2cb50732817cbe4d"></a><!-- doxytag: member="regex.c::MATCHING_IN_FIRST_STRING" ref="a7c5c8716cb01b2ad2cb50732817cbe4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCHING_IN_FIRST_STRING&#160;&#160;&#160;(dend == end_match_1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03712">3712</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="afa99ec4acc4ecb2dc3c2d05da15d0e3f"></a><!-- doxytag: member="regex.c::MAX" ref="afa99ec4acc4ecb2dc3c2d05da15d0e3f" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((a) &gt; (b) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00378">378</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7244ab798f58214294b580ca0bb48552"></a><!-- doxytag: member="regex.c::MAX_BUF_SIZE" ref="a7244ab798f58214294b580ca0bb48552" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BUF_SIZE&#160;&#160;&#160;(1L &lt;&lt; 16)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01679">1679</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9c1cb14ecb36be1c3ff3c5a050ecc561"></a><!-- doxytag: member="regex.c::MAX_FAILURE_ITEMS" ref="a9c1cb14ecb36be1c3ff3c5a050ecc561" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_FAILURE_ITEMS&#160;&#160;&#160;(5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01399">1399</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="af1b3c3e22fe42152c272df6027b1bf4b"></a><!-- doxytag: member="regex.c::MAX_REGNUM" ref="af1b3c3e22fe42152c272df6027b1bf4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_REGNUM&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01716">1716</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a98d0dff0c7366f08562d8e8583df9bb9"></a><!-- doxytag: member="regex.c::memcmp" ref="a98d0dff0c7366f08562d8e8583df9bb9" args="(s1, s2, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memcmp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;bcmp (s1, s2, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00149">149</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aed653b4838032a2c5ce8960421c8cfd7"></a><!-- doxytag: member="regex.c::memcpy" ref="aed653b4838032a2c5ce8960421c8cfd7" args="(d, s, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memcpy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(bcopy (<a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>, d, <a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>), (d))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00152">152</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3acffbd305ee72dcd4593c0d8af64a4f"></a><!-- doxytag: member="regex.c::MIN" ref="a3acffbd305ee72dcd4593c0d8af64a4f" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((a) &lt; (b) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00379">379</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab79c167c4cd771eeb9f88cf07c8b66c2"></a><!-- doxytag: member="regex.c::NO_HIGHEST_ACTIVE_REG" ref="ab79c167c4cd771eeb9f88cf07c8b66c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_HIGHEST_ACTIVE_REG&#160;&#160;&#160;(1 &lt;&lt; BYTEWIDTH)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03779">3779</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a508c8adae6628ee43b8498249272efb9"></a><!-- doxytag: member="regex.c::NO_LOWEST_ACTIVE_REG" ref="a508c8adae6628ee43b8498249272efb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_LOWEST_ACTIVE_REG&#160;&#160;&#160;(NO_HIGHEST_ACTIVE_REG + 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03780">3780</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a070d2ce7b6bb7e5c05602aa8c308d0c4"></a><!-- doxytag: member="regex.c::NULL" ref="a070d2ce7b6bb7e5c05602aa8c308d0c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULL&#160;&#160;&#160;(void *)0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00268">268</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6c2bd568049066ea7c22fadaee2c894f"></a><!-- doxytag: member="regex.c::NUM_FAILURE_ITEMS" ref="a6c2bd568049066ea7c22fadaee2c894f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_FAILURE_ITEMS</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((0                            \
     ? 0 : highest_active_reg - lowest_active_reg + 1)  \
    * <a class="code" href="regex_8c.html#acc5ecaf7b97fde5acbc377a7003496d7">NUM_REG_ITEMS</a>)                    \
   + <a class="code" href="regex_8c.html#aa6fc40697161c66c2a8a7c72a9cb5e77">NUM_NONREG_ITEMS</a>)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01402">1402</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa6fc40697161c66c2a8a7c72a9cb5e77"></a><!-- doxytag: member="regex.c::NUM_NONREG_ITEMS" ref="aa6fc40697161c66c2a8a7c72a9cb5e77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_NONREG_ITEMS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01392">1392</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="acc5ecaf7b97fde5acbc377a7003496d7"></a><!-- doxytag: member="regex.c::NUM_REG_ITEMS" ref="acc5ecaf7b97fde5acbc377a7003496d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_REG_ITEMS&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01386">1386</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3084488315144c5c6df29f6368c7131f"></a><!-- doxytag: member="regex.c::PARAMS" ref="a3084488315144c5c6df29f6368c7131f" args="(args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARAMS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ospfclient_8c.html#aa24f72e6a4d6a997528142211b375496">args</a></td><td>)</td>
          <td>&#160;&#160;&#160;()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00042">42</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a557d2f1c16f9bd2123e55885ee447c06"></a><!-- doxytag: member="regex.c::PATFETCH" ref="a557d2f1c16f9bd2123e55885ee447c06" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PATFETCH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {<span class="keywordflow">if</span> (<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> == pend) <span class="keywordflow">return</span> <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea1dac7de6e0f142b32bcb50ed22fc7abd">REG_EEND</a>;                 \
    c = (<span class="keywordtype">unsigned</span> char) *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>++;                       \
    if (translate) c = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) translate[c];            \
  } while (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01581">1581</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a95ed173b1e65d739ab2d15cc9b738ed9"></a><!-- doxytag: member="regex.c::PATFETCH_RAW" ref="a95ed173b1e65d739ab2d15cc9b738ed9" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PATFETCH_RAW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {<span class="keywordflow">if</span> (<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> == pend) <span class="keywordflow">return</span> <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea1dac7de6e0f142b32bcb50ed22fc7abd">REG_EEND</a>;                 \
    c = (<span class="keywordtype">unsigned</span> char) *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>++;                       \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01590">1590</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a77ae0460c3885ddc73f4544ef494e402"></a><!-- doxytag: member="regex.c::PATUNFETCH" ref="a77ae0460c3885ddc73f4544ef494e402" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PATUNFETCH&#160;&#160;&#160;<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>--</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01596">1596</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8bebab7ed279441748e37304f7a2c78a"></a><!-- doxytag: member="regex.c::POINTER_TO_OFFSET" ref="a8bebab7ed279441748e37304f7a2c78a" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POINTER_TO_OFFSET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="regex_8c.html#a490c47f87b80eb6afdb77510567659e4">FIRST_STRING_P</a> (ptr)               \
   ? ((<a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>) ((ptr) - string1))     \
   : ((<a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>) ((ptr) - string2 + size1)))
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l03705">3705</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3dd24cbefa49fcb9c198ead90fed08bb"></a><!-- doxytag: member="regex.c::POP_FAILURE_ELT" ref="a3dd24cbefa49fcb9c198ead90fed08bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POP_FAILURE_ELT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;fail_stack.stack[--fail_stack.avail]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01287">1287</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9f6a9e7cd2ec7f1a660dbdad98f7ccd3"></a><!-- doxytag: member="regex.c::POP_FAILURE_INT" ref="a9f6a9e7cd2ec7f1a660dbdad98f7ccd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POP_FAILURE_INT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;fail_stack.stack[--fail_stack.avail].integer</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01286">1286</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a51d78204b5e3cc240058c986103c8b8e"></a><!-- doxytag: member="regex.c::POP_FAILURE_POINT" ref="a51d78204b5e3cc240058c986103c8b8e" args="(str, pat, low_reg, high_reg, regstart, regend, reg_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POP_FAILURE_POINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ripng__zebra_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pat, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">low_reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">high_reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">regstart, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">regend, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg_info&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01424">1424</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="abde0e78c06d9082788a9f5f0a08140cd"></a><!-- doxytag: member="regex.c::POP_FAILURE_POINTER" ref="abde0e78c06d9082788a9f5f0a08140cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POP_FAILURE_POINTER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;fail_stack.stack[--fail_stack.avail].pointer</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01285">1285</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a03e91c701217af9b9faab62cb2a65d7d"></a><!-- doxytag: member="regex.c::PREFETCH" ref="a03e91c701217af9b9faab62cb2a65d7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFETCH</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">while</span> (d == dend)                               \
    {                                   \
      <span class="comment">/* End of string2 =&gt; fail.  */</span>                    \
      if (dend == end_match_2)                      \
        goto fail;                          \
      <span class="comment">/* End of string1 =&gt; advance to string2.  */</span>          \
      d = string2;                              \
      dend = end_match_2;                       \
    }
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l03716">3716</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad2265d63a0d1735021b318f4726920f9"></a><!-- doxytag: member="regex.c::PUSH_FAILURE_ELT" ref="ad2265d63a0d1735021b318f4726920f9" args="(item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_FAILURE_ELT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item</td><td>)</td>
          <td>&#160;&#160;&#160;fail_stack.stack[fail_stack.avail++] =  (item)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01280">1280</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab92b2a4088d04570c444979b2c7f909c"></a><!-- doxytag: member="regex.c::PUSH_FAILURE_INT" ref="ab92b2a4088d04570c444979b2c7f909c" args="(item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_FAILURE_INT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item</td><td>)</td>
          <td>&#160;&#160;&#160;fail_stack.stack[fail_stack.avail++].integer = (item)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01274">1274</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a74904744b0c1f8fe8cb2bf1584da2b3b"></a><!-- doxytag: member="regex.c::PUSH_FAILURE_POINT" ref="a74904744b0c1f8fe8cb2bf1584da2b3b" args="(pattern_place, string_place, failure_code)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_FAILURE_POINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pattern_place, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">string_place, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">failure_code&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01308">1308</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a880b2917876e9b98f61d985cef56109e"></a><!-- doxytag: member="regex.c::PUSH_FAILURE_POINTER" ref="a880b2917876e9b98f61d985cef56109e" args="(item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_FAILURE_POINTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item</td><td>)</td>
          <td>&#160;&#160;&#160;fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01268">1268</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a78ae8e3bdec768f7fd9a75b31109fa8d"></a><!-- doxytag: member="regex.c::PUSH_PATTERN_OP" ref="a78ae8e3bdec768f7fd9a75b31109fa8d" args="(POINTER, FAIL_STACK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_PATTERN_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">POINTER, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FAIL_STACK&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="regex_8c.html#ae2c89df0b8a642151867be8aaab52b44">FAIL_STACK_FULL</a> ()                            \
    &amp;&amp; !<a class="code" href="regex_8c.html#a138c79633bb68c93b6f7b7a31989fd0c">DOUBLE_FAIL_STACK</a> (FAIL_STACK))                 \
   ? 0                                  \
   : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,   \
      1))
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01258">1258</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a17d9af8542e3c215a173f67977fb06aa"></a><!-- doxytag: member="regex.c::REALLOC" ref="a17d9af8542e3c215a173f67977fb06aa" args="(p, s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;realloc ((<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>), (<a class="el" href="spgrid_8c.html#a5d97d3b42a0d6c9ec9a3e56f2616a6a5">s</a>))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01680">1680</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4d53631524c3e1f51d75b3d50f04d8ed"></a><!-- doxytag: member="regex.c::REG_BADBR_IDX" ref="a4d53631524c3e1f51d75b3d50f04d8ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_BADBR_IDX&#160;&#160;&#160;(REG_EBRACE_IDX + sizeof &quot;Unmatched \\{&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a48ae85c8247f711c7612edf7783e857c"></a><!-- doxytag: member="regex.c::REG_BADPAT_IDX" ref="a48ae85c8247f711c7612edf7783e857c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_BADPAT_IDX&#160;&#160;&#160;(REG_NOMATCH_IDX + sizeof &quot;No match&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf4d9e47a0ca86890be7bee5fc73aceb"></a><!-- doxytag: member="regex.c::REG_BADRPT_IDX" ref="acf4d9e47a0ca86890be7bee5fc73aceb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_BADRPT_IDX&#160;&#160;&#160;(REG_ESPACE_IDX + sizeof &quot;Memory exhausted&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae63f97c2af9852820b09ada8117982f3"></a><!-- doxytag: member="regex.c::REG_EBRACE_IDX" ref="ae63f97c2af9852820b09ada8117982f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_EBRACE_IDX&#160;&#160;&#160;(REG_EPAREN_IDX + sizeof &quot;Unmatched ( or \\(&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a206525485bf45f18ebf8fd0fcab5f3cd"></a><!-- doxytag: member="regex.c::REG_EBRACK_IDX" ref="a206525485bf45f18ebf8fd0fcab5f3cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_EBRACK_IDX&#160;&#160;&#160;(REG_ESUBREG_IDX + sizeof &quot;Invalid back reference&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c414c00809d9b700e9d8071c4d8b051"></a><!-- doxytag: member="regex.c::REG_ECOLLATE_IDX" ref="a6c414c00809d9b700e9d8071c4d8b051" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ECOLLATE_IDX&#160;&#160;&#160;(REG_BADPAT_IDX + sizeof &quot;Invalid regular expression&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acdb862b0439091c6aba1ddb34ec74c9f"></a><!-- doxytag: member="regex.c::REG_ECTYPE_IDX" ref="acdb862b0439091c6aba1ddb34ec74c9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ECTYPE_IDX&#160;&#160;&#160;(REG_ECOLLATE_IDX + sizeof &quot;Invalid collation character&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f5131e9e883c6f787f7c1041d3d3f1a"></a><!-- doxytag: member="regex.c::REG_EEND_IDX" ref="a5f5131e9e883c6f787f7c1041d3d3f1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_EEND_IDX&#160;&#160;&#160;(REG_BADRPT_IDX + sizeof &quot;Invalid preceding regular expression&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94bc4724ebb8f838d053f9f10fa3981a"></a><!-- doxytag: member="regex.c::REG_EESCAPE_IDX" ref="a94bc4724ebb8f838d053f9f10fa3981a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_EESCAPE_IDX&#160;&#160;&#160;(REG_ECTYPE_IDX + sizeof &quot;Invalid character class <a class="el" href="memory_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab27649935fb8e05dd687d0d1e738697a"></a><!-- doxytag: member="regex.c::REG_EPAREN_IDX" ref="ab27649935fb8e05dd687d0d1e738697a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_EPAREN_IDX&#160;&#160;&#160;(REG_EBRACK_IDX + sizeof &quot;Unmatched [ or [^&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9335e944484ecf3dac6270666feaaf1f"></a><!-- doxytag: member="regex.c::REG_ERANGE_IDX" ref="a9335e944484ecf3dac6270666feaaf1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ERANGE_IDX&#160;&#160;&#160;(REG_BADBR_IDX + sizeof &quot;Invalid content of \\{\\}&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a212c67e65cef62a14bc026104b3965"></a><!-- doxytag: member="regex.c::REG_ERPAREN_IDX" ref="a7a212c67e65cef62a14bc026104b3965" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ERPAREN_IDX&#160;&#160;&#160;(REG_ESIZE_IDX + sizeof &quot;Regular expression too big&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa86dc74b96a36fc455d490601cab5529"></a><!-- doxytag: member="regex.c::REG_ESIZE_IDX" ref="aa86dc74b96a36fc455d490601cab5529" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ESIZE_IDX&#160;&#160;&#160;(REG_EEND_IDX + sizeof &quot;Premature end of regular expression&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af6d28ac4aa08afd5fe52f7fd43abc5bb"></a><!-- doxytag: member="regex.c::REG_ESPACE_IDX" ref="af6d28ac4aa08afd5fe52f7fd43abc5bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ESPACE_IDX&#160;&#160;&#160;(REG_ERANGE_IDX + sizeof &quot;Invalid range end&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aacadf8be59807dfbb1e55d08c26744b9"></a><!-- doxytag: member="regex.c::REG_ESUBREG_IDX" ref="aacadf8be59807dfbb1e55d08c26744b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_ESUBREG_IDX&#160;&#160;&#160;(REG_EESCAPE_IDX + sizeof &quot;Trailing backslash&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac840f4f2ecf1841ed894bd361236715b"></a><!-- doxytag: member="regex.c::REG_MATCH_NULL_STRING_P" ref="ac840f4f2ecf1841ed894bd361236715b" args="(R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_MATCH_NULL_STRING_P</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R</td><td>)</td>
          <td>&#160;&#160;&#160;((R).bits.match_null_string_p)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01523">1523</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a53cac93056e7e4dcd77c87fd5b64ab85"></a><!-- doxytag: member="regex.c::REG_NOERROR_IDX" ref="a53cac93056e7e4dcd77c87fd5b64ab85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_NOERROR_IDX&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20c488a0672699e12eebb87f4536a2a1"></a><!-- doxytag: member="regex.c::REG_NOMATCH_IDX" ref="a20c488a0672699e12eebb87f4536a2a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_NOMATCH_IDX&#160;&#160;&#160;(REG_NOERROR_IDX + sizeof &quot;Success&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afefb76392029f59835538d01a0c13242"></a><!-- doxytag: member="regex.c::REG_UNSET" ref="afefb76392029f59835538d01a0c13242" args="(e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_UNSET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e) == REG_UNSET_VALUE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01552">1552</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a78d7e87774e3c9ae84570f8ab88f55a5"></a><!-- doxytag: member="regex.c::REG_UNSET_VALUE" ref="a78d7e87774e3c9ae84570f8ab88f55a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REG_UNSET_VALUE&#160;&#160;&#160;(&amp;<a class="el" href="regex_8c.html#aadf22463a9896cf91277d88f89246e43">reg_unset_dummy</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01551">1551</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac0f85b18908da63fd510f189601c2a9c"></a><!-- doxytag: member="regex.c::REGEX_ALLOCATE" ref="ac0f85b18908da63fd510f189601c2a9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_ALLOCATE&#160;&#160;&#160;alloca</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00315">315</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a37f419167ca1f8c499ee4c899b53614b"></a><!-- doxytag: member="regex.c::REGEX_ALLOCATE_STACK" ref="a37f419167ca1f8c499ee4c899b53614b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_ALLOCATE_STACK&#160;&#160;&#160;alloca</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00348">348</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aea9786147160a9d7734726ed1b60a8db"></a><!-- doxytag: member="regex.c::REGEX_FREE" ref="aea9786147160a9d7734726ed1b60a8db" args="(arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg</td><td>)</td>
          <td>&#160;&#160;&#160;((void)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00323">323</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6eea4d3debda32ae12ea46de7cf1a11f"></a><!-- doxytag: member="regex.c::REGEX_FREE_STACK" ref="a6eea4d3debda32ae12ea46de7cf1a11f" args="(arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_FREE_STACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00353">353</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3694b4c0eee68e086e659d2508cf618a"></a><!-- doxytag: member="regex.c::REGEX_REALLOCATE" ref="a3694b4c0eee68e086e659d2508cf618a" args="(source, osize, nsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_REALLOCATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">osize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nsize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(destination = (<span class="keywordtype">char</span> *) alloca (nsize),             \
   memcpy (destination, <a class="code" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, osize))
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l00318">318</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9247bcb7e41d886eaac155949a0e58e0"></a><!-- doxytag: member="regex.c::REGEX_REALLOCATE_STACK" ref="a9247bcb7e41d886eaac155949a0e58e0" args="(source, osize, nsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_REALLOCATE_STACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">osize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nsize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;REGEX_REALLOCATE (<a class="el" href="spgrid_8c.html#acef278b54e17ed729da5acd28bda6daf">source</a>, osize, nsize)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00350">350</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa55c07b38a55837693a65170c5aa4c76"></a><!-- doxytag: member="regex.c::REGEX_TALLOC" ref="aa55c07b38a55837693a65170c5aa4c76" args="(n, t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGEX_TALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a> *) REGEX_ALLOCATE ((<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>) * sizeof (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00370">370</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3c10fb30732d92eb33b8d2d0a2817e7b"></a><!-- doxytag: member="regex.c::REMAINING_AVAIL_SLOTS" ref="a3c10fb30732d92eb33b8d2d0a2817e7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REMAINING_AVAIL_SLOTS&#160;&#160;&#160;((fail_stack).size - (fail_stack).avail)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01409">1409</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="af9f8d0785dfac45a23d8d8fdb4df1629"></a><!-- doxytag: member="regex.c::RESET_FAIL_STACK" ref="af9f8d0785dfac45a23d8d8fdb4df1629" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESET_FAIL_STACK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;REGEX_FREE_STACK (fail_stack.stack)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01223">1223</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae247cb248fa0309737dce6bdfc3a6a3d"></a><!-- doxytag: member="regex.c::RETALLOC" ref="ae247cb248fa0309737dce6bdfc3a6a3d" args="(addr, n, t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((addr) = (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a> *) realloc (addr, (<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>) * sizeof (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00367">367</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a12c694618416cdfd35b3eb0e7f99f7f6"></a><!-- doxytag: member="regex.c::RETALLOC_IF" ref="a12c694618416cdfd35b3eb0e7f99f7f6" args="(addr, n, t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETALLOC_IF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if (addr) RETALLOC((addr), (<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>), <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>); else (addr) = TALLOC ((<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>), <a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00368">368</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa09a4c3c61b8d82d7134225bfd5a32f7"></a><!-- doxytag: member="regex.c::SET_LIST_BIT" ref="aa09a4c3c61b8d82d7134225bfd5a32f7" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SET_LIST_BIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>[((<span class="keywordtype">unsigned</span> char) (c)) / <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>]               \
   |= 1 &lt;&lt; (((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) c) % <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>))
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01758">1758</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa286396ee78a5823c6bedd72e303e4c9"></a><!-- doxytag: member="regex.c::SET_REGS_MATCHED" ref="aa286396ee78a5823c6bedd72e303e4c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SET_REGS_MATCHED</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span>                                  \
    {                                   \
      if (!set_regs_matched_done)                   \
    {                               \
      active_reg_t r;                       \
      set_regs_matched_done = 1;                    \
      for (r = lowest_active_reg; r &lt;= highest_active_reg; r++) \
        {                               \
          MATCHED_SOMETHING (reg_info[r])               \
        = <a class="code" href="regex_8c.html#ad4e9639db811e6b09f31ff92466b404e">EVER_MATCHED_SOMETHING</a> (reg_info[r])          \
        = 1;                            \
        }                               \
    }                               \
    }                                   \
  while (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01532">1532</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="affd804aa116f7d43493d29c6607df14d"></a><!-- doxytag: member="regex.c::SIGN_EXTEND_CHAR" ref="affd804aa116f7d43493d29c6607df14d" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGN_EXTEND_CHAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;((((unsigned char) (c)) ^ 128) - 128)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00280">280</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="acfebc9fd667ce5b7d2162f2677087e21"></a><!-- doxytag: member="regex.c::STORE_JUMP" ref="acfebc9fd667ce5b7d2162f2677087e21" args="(op, loc, to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORE_JUMP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">loc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">to&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;store_op1 (op, loc, (int) ((to) - (loc) - 3))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01648">1648</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa2aa60706e57e51cc9b54ff2c8cc38a2"></a><!-- doxytag: member="regex.c::STORE_JUMP2" ref="aa2aa60706e57e51cc9b54ff2c8cc38a2" args="(op, loc, to, arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORE_JUMP2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">loc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">to, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;store_op2 (op, loc, (int) ((to) - (loc) - 3), arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01652">1652</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6878991bbaf83ac3debe1d74f4a450e1"></a><!-- doxytag: member="regex.c::STORE_NUMBER" ref="a6878991bbaf83ac3debe1d74f4a450e1" args="(destination, number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORE_NUMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">number&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    (destination)[0] = (number) &amp; 0377;                 \
    (destination)[1] = (number) &gt;&gt; 8;                   \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l00535">535</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aec2d0e7545b2756d65a556d3ac7cdf89"></a><!-- doxytag: member="regex.c::STORE_NUMBER_AND_INCR" ref="aec2d0e7545b2756d65a556d3ac7cdf89" args="(destination, number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORE_NUMBER_AND_INCR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">number&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
    STORE_NUMBER (destination, number);                 \
    (destination) += 2;                         \
  } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l00545">545</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab42511b5b7bf70ad31b13c44469d117f"></a><!-- doxytag: member="regex.c::STREQ" ref="ab42511b5b7bf70ad31b13c44469d117f" args="(s1, s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STREQ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((strcmp (s1, s2) == 0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00374">374</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a95cf7f68f7a75751d4abd454d6add11a"></a><!-- doxytag: member="regex.c::SWITCH_ENUM_CAST" ref="a95cf7f68f7a75751d4abd454d6add11a" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SWITCH_ENUM_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#a3162ada50d1df39e0f0555ea3d60dea1">x</a></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="spgrid_8c.html#a3162ada50d1df39e0f0555ea3d60dea1">x</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00168">168</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3c4fa96131648fe8cb5bb3055015e73a"></a><!-- doxytag: member="regex.c::Sword" ref="a3c4fa96131648fe8cb5bb3055015e73a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sword&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00162">162</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa3ac3cf24b0571b34350ae5cf10f354e"></a><!-- doxytag: member="regex.c::SYNTAX" ref="aa3ac3cf24b0571b34350ae5cf10f354e" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYNTAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[c]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00209">209</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aaf77bcbd178f50762a35333d83bacd09"></a><!-- doxytag: member="regex.c::TALLOC" ref="aaf77bcbd178f50762a35333d83bacd09" args="(n, t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a> *) malloc ((<a class="el" href="spgrid_8c.html#abe63e991a7bf5d666068b15c9064428d">n</a>) * sizeof (<a class="el" href="test-sig_8c.html#ab4ed0bba3292270af8ad67b45a21280d">t</a>)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00366">366</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad4771ad2e5dd6a87c83ecf879b7985de"></a><!-- doxytag: member="regex.c::TOLOWER" ref="ad4771ad2e5dd6a87c83ecf879b7985de" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOLOWER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;tolower(c)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00264">264</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2eeeb49b77aa0f299d2d3c23dc1bfa17"></a><!-- doxytag: member="regex.c::TRANSLATE" ref="a2eeeb49b77aa0f299d2d3c23dc1bfa17" args="(d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRANSLATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d</td><td>)</td>
          <td>&#160;&#160;&#160;(translate ? (char) translate[(unsigned char) (d)] : (d))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01604">1604</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a41f9c5fb8b08eb5dc3edce4dcb37fee7"></a><!-- doxytag: member="regex.c::true" ref="a41f9c5fb8b08eb5dc3edce4dcb37fee7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define true&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00383">383</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6640e68e2e8afe5fa53c6899403630a8"></a><!-- doxytag: member="regex.c::WIDE_CHAR_SUPPORT" ref="a6640e68e2e8afe5fa53c6899403630a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIDE_CHAR_SUPPORT&#160;&#160;&#160;(HAVE_WCTYPE_H &amp;&amp; HAVE_WCHAR_H &amp;&amp; HAVE_BTOWC)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00053">53</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9cb82d6af5bb56ce088c91cef5127ce6"></a><!-- doxytag: member="regex.c::WORDCHAR_P" ref="a9cb82d6af5bb56ce088c91cef5127ce6" args="(d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORDCHAR_P</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> ((d) == end1 ? *string2                 \
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))           \
   == <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>)
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l03738">3738</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a330a2ea4da1ce57c189821c8ebf59618"></a><!-- doxytag: member="regex.c::boolean" ref="a330a2ea4da1ce57c189821c8ebf59618" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00381">381</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad124700b566688232f5fb6638b679858"></a><!-- doxytag: member="regex.c::fail_stack_elt_t" ref="ad124700b566688232f5fb6638b679858" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionfail__stack__elt.html">fail_stack_elt</a> <a class="el" href="regex_8c.html#ad124700b566688232f5fb6638b679858">fail_stack_elt_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01191">1191</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a389ceb5c54c193f7b942544f6b0fe9b0"></a><!-- doxytag: member="regex.c::pattern_offset_t" ref="a389ceb5c54c193f7b942544f6b0fe9b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="regex_8c.html#a389ceb5c54c193f7b942544f6b0fe9b0">pattern_offset_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01728">1728</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9e5a8ee5ece120e8e7b7c28eea3aa7cd"></a><!-- doxytag: member="regex.c::regnum_t" ref="a9e5a8ee5ece120e8e7b7c28eea3aa7cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01720">1720</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad1f757f0a86665780f50f812767b2118"></a><!-- doxytag: member="regex.c::re_opcode_t" ref="ad1f757f0a86665780f50f812767b2118" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836"></a><!-- doxytag: member="no_op" ref="ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836" args="" -->no_op</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9"></a><!-- doxytag: member="succeed" ref="ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9" args="" -->succeed</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1"></a><!-- doxytag: member="exactn" ref="ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1" args="" -->exactn</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648"></a><!-- doxytag: member="anychar" ref="ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648" args="" -->anychar</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88"></a><!-- doxytag: member="charset" ref="ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88" args="" -->charset</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e"></a><!-- doxytag: member="charset_not" ref="ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e" args="" -->charset_not</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e"></a><!-- doxytag: member="start_memory" ref="ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e" args="" -->start_memory</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9"></a><!-- doxytag: member="stop_memory" ref="ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9" args="" -->stop_memory</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de"></a><!-- doxytag: member="duplicate" ref="ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de" args="" -->duplicate</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107"></a><!-- doxytag: member="begline" ref="ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107" args="" -->begline</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4"></a><!-- doxytag: member="endline" ref="ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4" args="" -->endline</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598"></a><!-- doxytag: member="begbuf" ref="ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598" args="" -->begbuf</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775"></a><!-- doxytag: member="endbuf" ref="ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775" args="" -->endbuf</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849"></a><!-- doxytag: member="jump" ref="ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849" args="" -->jump</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da"></a><!-- doxytag: member="jump_past_alt" ref="ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da" args="" -->jump_past_alt</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287"></a><!-- doxytag: member="on_failure_jump" ref="ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287" args="" -->on_failure_jump</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b"></a><!-- doxytag: member="on_failure_keep_string_jump" ref="ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b" args="" -->on_failure_keep_string_jump</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb"></a><!-- doxytag: member="pop_failure_jump" ref="ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb" args="" -->pop_failure_jump</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b"></a><!-- doxytag: member="maybe_pop_jump" ref="ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b" args="" -->maybe_pop_jump</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba"></a><!-- doxytag: member="dummy_failure_jump" ref="ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba" args="" -->dummy_failure_jump</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f"></a><!-- doxytag: member="push_dummy_failure" ref="ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f" args="" -->push_dummy_failure</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734"></a><!-- doxytag: member="succeed_n" ref="ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734" args="" -->succeed_n</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b"></a><!-- doxytag: member="jump_n" ref="ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b" args="" -->jump_n</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1"></a><!-- doxytag: member="set_number_at" ref="ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1" args="" -->set_number_at</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b"></a><!-- doxytag: member="wordchar" ref="ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b" args="" -->wordchar</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93"></a><!-- doxytag: member="notwordchar" ref="ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93" args="" -->notwordchar</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18"></a><!-- doxytag: member="wordbeg" ref="ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18" args="" -->wordbeg</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac"></a><!-- doxytag: member="wordend" ref="ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac" args="" -->wordend</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9"></a><!-- doxytag: member="wordbound" ref="ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9" args="" -->wordbound</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0"></a><!-- doxytag: member="notwordbound" ref="ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0" args="" -->notwordbound</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="regex_8c_source.html#l00397">397</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a> = 0,

  <span class="comment">/* Succeed right away--no more backtracking.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9">succeed</a>,

        <span class="comment">/* Followed by one byte giving n, then by n literal bytes.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>,

        <span class="comment">/* Matches any (more or less) character.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648">anychar</a>,

        <span class="comment">/* Matches any one char belonging to specified set.  First</span>
<span class="comment">           following byte is number of bitmap bytes.  Then come bytes</span>
<span class="comment">           for a bitmap saying which chars are in.  Bits in each byte</span>
<span class="comment">           are ordered low-bit-first.  A character is in the set if its</span>
<span class="comment">           bit is 1.  A character too large to have a bit in the map is</span>
<span class="comment">           automatically not in the set.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>,

        <span class="comment">/* Same parameters as charset, but match any character that is</span>
<span class="comment">           not one of those specified.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>,

        <span class="comment">/* Start remembering the text that is matched, for storing in a</span>
<span class="comment">           register.  Followed by one byte with the register number, in</span>
<span class="comment">           the range 0 to one less than the pattern buffer&#39;s re_nsub</span>
<span class="comment">           field.  Then followed by one byte with the number of groups</span>
<span class="comment">           inner to this one.  (This last has to be part of the</span>
<span class="comment">           start_memory only because we need it in the on_failure_jump</span>
<span class="comment">           of re_match_2.)  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>,

        <span class="comment">/* Stop remembering the text that is matched and store it in a</span>
<span class="comment">           memory register.  Followed by one byte with the register</span>
<span class="comment">           number, in the range 0 to one less than `re_nsub&#39; in the</span>
<span class="comment">           pattern buffer, and one byte with the number of inner groups,</span>
<span class="comment">           just like `start_memory&#39;.  (We need the number of inner</span>
<span class="comment">           groups here because we don&#39;t have any easy way of finding the</span>
<span class="comment">           corresponding start_memory when we&#39;re at a stop_memory.)  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>,

        <span class="comment">/* Match a duplicate of something remembered. Followed by one</span>
<span class="comment">           byte containing the register number.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de">duplicate</a>,

        <span class="comment">/* Fail unless at beginning of line.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>,

        <span class="comment">/* Fail unless at end of line.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>,

        <span class="comment">/* Succeeds if at beginning of buffer (if emacs) or at beginning</span>
<span class="comment">           of string to be matched (if not).  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>,

        <span class="comment">/* Analogously, for end of buffer/string.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775">endbuf</a>,

        <span class="comment">/* Followed by two byte relative address to which to jump.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>,

    <span class="comment">/* Same as jump, but marks the end of an alternative.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>,

        <span class="comment">/* Followed by two-byte relative address of place to resume at</span>
<span class="comment">           in case of failure.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>,

        <span class="comment">/* Like on_failure_jump, but pushes a placeholder instead of the</span>
<span class="comment">           current string position when executed.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b">on_failure_keep_string_jump</a>,

        <span class="comment">/* Throw away latest failure point and then jump to following</span>
<span class="comment">           two-byte relative address.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>,

        <span class="comment">/* Change to pop_failure_jump if know won&#39;t have to backtrack to</span>
<span class="comment">           match; otherwise change to jump.  This is used to jump</span>
<span class="comment">           back to the beginning of a repeat.  If what follows this jump</span>
<span class="comment">           clearly won&#39;t match what the repeat does, such that we can be</span>
<span class="comment">           sure that there is no use backtracking out of repetitions</span>
<span class="comment">           already matched, then we change it to a pop_failure_jump.</span>
<span class="comment">           Followed by two-byte address.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>,

        <span class="comment">/* Jump to following two-byte address, and push a dummy failure</span>
<span class="comment">           point. This failure point will be thrown away if an attempt</span>
<span class="comment">           is made to use it for a failure.  A `+&#39; construct makes this</span>
<span class="comment">           before the first repeat.  Also used as an intermediary kind</span>
<span class="comment">           of jump when compiling an alternative.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>,

    <span class="comment">/* Push a dummy failure point and continue.  Used at the end of</span>
<span class="comment">       alternatives.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f">push_dummy_failure</a>,

        <span class="comment">/* Followed by two-byte relative address and two-byte number n.</span>
<span class="comment">           After matching N times, jump to the address upon failure.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>,

        <span class="comment">/* Followed by two-byte relative address, and two-byte number n.</span>
<span class="comment">           Jump to the address N times, then fail.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>,

        <span class="comment">/* Set the following two-byte relative address to the</span>
<span class="comment">           subsequent two-byte number.  The address *includes* the two</span>
<span class="comment">           bytes of number.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>,

  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b">wordchar</a>, <span class="comment">/* Matches any word-constituent character.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93">notwordchar</a>,  <span class="comment">/* Matches any char that is not a word-constituent.  */</span>

  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18">wordbeg</a>,  <span class="comment">/* Succeeds if at word beginning.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac">wordend</a>,  <span class="comment">/* Succeeds if at word end.  */</span>

  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>,    <span class="comment">/* Succeeds if at a word boundary.  */</span>
  <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>  <span class="comment">/* Succeeds if not at a word boundary.  */</span>

<span class="preprocessor">#ifdef emacs</span>
<span class="preprocessor"></span>  ,before_dot,  <span class="comment">/* Succeeds if before point.  */</span>
  at_dot,   <span class="comment">/* Succeeds if at point.  */</span>
  after_dot,    <span class="comment">/* Succeeds if after point.  */</span>

    <span class="comment">/* Matches any character whose syntax is specified.  Followed by</span>
<span class="comment">           a byte which contains a syntax code, e.g., Sword.  */</span>
  syntaxspec,

    <span class="comment">/* Matches any character whose syntax is not that specified.  */</span>
  notsyntaxspec
<span class="preprocessor">#endif </span><span class="comment">/* emacs */</span>
} <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>;
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a14b1265b519e06f4ffc1221680e909ca"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a14b1265b519e06f4ffc1221680e909ca" args="((const char *pattern, size_t size, reg_syntax_t syntax, struct re_pattern_buffer *bufp))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> regex_compile _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(const char *pattern, size_t size, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax, struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb7757b9bc334d1e99688ab54a22cf1e"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="acb7757b9bc334d1e99688ab54a22cf1e" args="((re_opcode_t op, unsigned char *loc, int arg))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void store_op1 _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aabc5d51462aef5afd8dc58daabc7ae6c"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="aabc5d51462aef5afd8dc58daabc7ae6c" args="((re_opcode_t op, unsigned char *loc, int arg1, int arg2))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void store_op2 _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg1, int arg2)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0dab1e53ffa7b48a0c30b2570a8fde04"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a0dab1e53ffa7b48a0c30b2570a8fde04" args="((re_opcode_t op, unsigned char *loc, int arg, unsigned char *end))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void insert_op1 _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg, unsigned char *end)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85ed0b079e32e0a896a188a0a2a2ece9"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a85ed0b079e32e0a896a188a0a2a2ece9" args="((re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void insert_op2 _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a> op, unsigned char *loc, int arg1, int arg2, unsigned char *end)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a105e31ac3d4f239a5d1cd77caba72a44"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a105e31ac3d4f239a5d1cd77caba72a44" args="((const char *pattern, const char *p, reg_syntax_t syntax))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> at_begline_loc_p _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(const char *pattern, const char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8394fb66b955785b3b6db5b48d8d9024"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a8394fb66b955785b3b6db5b48d8d9024" args="((const char *p, const char *pend, reg_syntax_t syntax))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> at_endline_loc_p _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(const char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, const char *pend, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3474ca08abb941a8e94f475348dde76c"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a3474ca08abb941a8e94f475348dde76c" args="((const char **p_ptr, const char *pend, char *translate, reg_syntax_t syntax, unsigned char *b))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> compile_range _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(const char **p_ptr, const char *pend, char *translate, <a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax, unsigned char *b)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a393d07733691ef82a065f7018d7a23e9"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a393d07733691ef82a065f7018d7a23e9" args="((compile_stack_typecompile_stack, regnum_t regnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> group_in_compile_stack _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(compile_stack_typecompile_stack, <a class="el" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a> regnum)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeeb88cd4db21f162f7defe3ded754a1d"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="aeeb88cd4db21f162f7defe3ded754a1d" args="((unsigned char **p, unsigned char *end, register_info_type *reg_info))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> common_op_match_null_string_p _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(unsigned char **<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1573e54893ddab823f7fa6702d3ed5f2"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="a1573e54893ddab823f7fa6702d3ed5f2" args="((unsigned char *p, unsigned char *end, register_info_type *reg_info))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> alt_match_null_string_p _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(unsigned char *<a class="el" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>, unsigned char *end, <a class="el" href="unionregister__info__type.html">register_info_type</a> *reg_info)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af2a3c6789600240daf5204840c139b64"></a><!-- doxytag: member="regex.c::_RE_ARGS" ref="af2a3c6789600240daf5204840c139b64" args="((const char *s1, const char *s2, int len, char *translate))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bcmp_translate _RE_ARGS </td>
          <td>(</td>
          <td class="paramtype">(const char *s1, const char *s2, int len, char *translate)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d088a8cdab2f2daa400a5df18cbf594"></a><!-- doxytag: member="regex.c::alt_match_null_string_p" ref="a4d088a8cdab2f2daa400a5df18cbf594" args="(unsigned char *p, unsigned char *end, register_info_type *reg_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> alt_match_null_string_p </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionregister__info__type.html">register_info_type</a> *&#160;</td>
          <td class="paramname"><em>reg_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05370">5370</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> mcnt;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p1 = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

  <span class="keywordflow">while</span> (p1 &lt; end)
    {
      <span class="comment">/* Skip over opcodes that can match nothing, and break when we get</span>
<span class="comment">         to one that can&#39;t.  */</span>

      <span class="keywordflow">switch</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1)
        {
    <span class="comment">/* It&#39;s a loop.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>:
          p1++;
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
          p1 += mcnt;
          <span class="keywordflow">break</span>;

    <span class="keywordflow">default</span>:
          <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a97ff784b1a6ed91bbc1013a3a44a05da">common_op_match_null_string_p</a> (&amp;p1, end, reg_info))
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
</pre></div>
</div>
</div>
<a class="anchor" id="a9fcec6851521f04076e51adfa274403c"></a><!-- doxytag: member="regex.c::at_begline_loc_p" ref="a9fcec6851521f04076e51adfa274403c" args="(char *pattern, char *p, reg_syntax_t syntax) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> at_begline_loc_p </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td>
          <td class="paramname"><em>syntax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03063">3063</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">char</span> *prev = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> - 2;
  <span class="keywordtype">boolean</span> prev_prev_backslash = prev &gt; pattern &amp;&amp; prev[-1] == <span class="charliteral">&#39;\\&#39;</span>;

  <span class="keywordflow">return</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a85a9d04db18bdf4b65ea1113400613e4"></a><!-- doxytag: member="regex.c::at_endline_loc_p" ref="a85a9d04db18bdf4b65ea1113400613e4" args="(char *p, char *pend, reg_syntax_t syntax) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> at_endline_loc_p </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td>
          <td class="paramname"><em>syntax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03082">3082</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">char</span> *next = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;
  <span class="keywordtype">boolean</span> next_backslash = *next == <span class="charliteral">&#39;\\&#39;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *next_next = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> + 1 &lt; pend ? <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> + 1 : 0;

  <span class="keywordflow">return</span>
       <span class="comment">/* Before a subexpression?  */</span>
       (syntax &amp; <a class="code" href="regex-gnu_8h.html#af2f17f18a9c771c91d963f466f559e68">RE_NO_BK_PARENS</a> ? *next == <span class="charliteral">&#39;)&#39;</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a831fca3c806cff281a70c8757c40b134"></a><!-- doxytag: member="regex.c::bcmp_translate" ref="a831fca3c806cff281a70c8757c40b134" args="(char *s1, char *s2, int len, RE_TRANSLATE_TYPE translate) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bcmp_translate </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RE_TRANSLATE_TYPE&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05495">5495</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">register</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p1 = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) s1;
  <span class="keyword">register</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p2 = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) s2;
  <span class="keywordflow">while</span> (len)
    {
</pre></div>
</div>
</div>
<a class="anchor" id="a97ff784b1a6ed91bbc1013a3a44a05da"></a><!-- doxytag: member="regex.c::common_op_match_null_string_p" ref="a97ff784b1a6ed91bbc1013a3a44a05da" args="(unsigned char **p, unsigned char *end, register_info_type *reg_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> common_op_match_null_string_p </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionregister__info__type.html">register_info_type</a> *&#160;</td>
          <td class="paramname"><em>reg_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05407">5407</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> mcnt;
  <span class="keywordtype">boolean</span> ret;
  <span class="keywordtype">int</span> reg_no;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p1 = *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

  <span class="keywordflow">switch</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1++)
    {
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775">endbuf</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18">wordbeg</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac">wordend</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>:
<span class="preprocessor">#ifdef emacs</span>
<span class="preprocessor"></span>    <span class="keywordflow">case</span> before_dot:
    <span class="keywordflow">case</span> at_dot:
    <span class="keywordflow">case</span> after_dot:
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>:
      reg_no = *p1;
      <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (reg_no &gt; 0 &amp;&amp; reg_no &lt;= <a class="code" href="regex_8c.html#af1b3c3e22fe42152c272df6027b1bf4b">MAX_REGNUM</a>);
      ret = <a class="code" href="regex_8c.html#ac1a3adc04ca27d22992ea483708c5812">group_match_null_string_p</a> (&amp;p1, end, reg_info);

      <span class="comment">/* Have to set this here in case we&#39;re checking a group which</span>
<span class="comment">         contains a group and a back reference to it.  */</span>

      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[reg_no]) == <a class="code" href="regex_8c.html#a9fbdd9b78059994c85d9f064f9fa9ec3">MATCH_NULL_UNSET_VALUE</a>)
        <a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[reg_no]) = ret;

      <span class="keywordflow">if</span> (!ret)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
      <span class="keywordflow">break</span>;

    <span class="comment">/* If this is an optimized succeed_n for zero times, make the jump.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>:
      <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
      <span class="keywordflow">if</span> (mcnt &gt;= 0)
        p1 += mcnt;
      <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>:
      <span class="comment">/* Get to the number of times to succeed.  */</span>
      p1 += 2;
      <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);

      <span class="keywordflow">if</span> (mcnt == 0)
        {
          p1 -= 4;
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
          p1 += mcnt;
        }
      <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de">duplicate</a>:
      <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[*p1]))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>:
      p1 += 4;

    <span class="keywordflow">default</span>:
      <span class="comment">/* All other opcodes mean we cannot match the empty string.  */</span>
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
</pre></div>
</div>
</div>
<a class="anchor" id="a06b0c1ae265d6791c041df0ddf6d7ff6"></a><!-- doxytag: member="regex.c::compile_range" ref="a06b0c1ae265d6791c041df0ddf6d7ff6" args="(char **p_ptr, char *pend, RE_TRANSLATE_TYPE translate, reg_syntax_t syntax, unsigned char *b) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> compile_range </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>p_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RE_TRANSLATE_TYPE&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td>
          <td class="paramname"><em>syntax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03132">3132</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> this_char;

  <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> = *p_ptr;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> range_start, range_end;

  <span class="keywordflow">if</span> (p == pend)
    <span class="keywordflow">return</span> <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea16489a654c428b506103ccc746adda00">REG_ERANGE</a>;

  <span class="comment">/* Even though the pattern is a signed `char *&#39;, we need to fetch</span>
<span class="comment">     with unsigned char *&#39;s; if the high bit of the pattern character</span>
<span class="comment">     is set, the range endpoints will be negative if we fetch using a</span>
<span class="comment">     signed char *.</span>
<span class="comment"></span>
<span class="comment">     We also want to fetch the endpoints without translating them; the</span>
<span class="comment">     appropriate translation is done in the bit-setting loop below.  */</span>
  <span class="comment">/* The SVR4 compiler on the 3B2 had trouble with unsigned const char *.  */</span>
  range_start = ((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p)[-2];
  range_end   = ((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p)[0];

  <span class="comment">/* Have to increment the pointer into the pattern string, so the</span>
<span class="comment">     caller isn&#39;t still at the ending character.  */</span>
  (*p_ptr)++;

  <span class="comment">/* If the start is after the end, the range is empty.  */</span>
  <span class="keywordflow">if</span> (range_start &gt; range_end)
    <span class="keywordflow">return</span> syntax &amp; <a class="code" href="regex-gnu_8h.html#ae01c1dfed60f209c2f10f252c3acf9fd">RE_NO_EMPTY_RANGES</a> ? <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea16489a654c428b506103ccc746adda00">REG_ERANGE</a> : <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeafa64e5a57596c8c859f982512f52cd6b">REG_NOERROR</a>;

  <span class="comment">/* Here we see why `this_char&#39; has to be larger than an `unsigned</span>
<span class="comment">     char&#39; -- the range is inclusive, so if `range_end&#39; == 0xff</span>
<span class="comment">     (assuming 8-bit characters), we would otherwise go into an infinite</span>
<span class="comment">     loop, since all characters &lt;= 0xff.  */</span>
  <span class="keywordflow">for</span> (this_char = range_start; this_char &lt;= range_end; this_char++)
    {
</pre></div>
</div>
</div>
<a class="anchor" id="a28dc5088ce179431d47162481e6c6540"></a><!-- doxytag: member="regex.c::group_in_compile_stack" ref="a28dc5088ce179431d47162481e6c6540" args="(compile_stack_type compile_stack, regnum_t regnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> group_in_compile_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcompile__stack__type.html">compile_stack_type</a>&#160;</td>
          <td class="paramname"><em>compile_stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a>&#160;</td>
          <td class="paramname"><em>regnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03104">3104</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> this_element;

  <span class="keywordflow">for</span> (this_element = compile_stack.<a class="code" href="structcompile__stack__type.html#a45982ffa38800f8a9502da9708ec587c">avail</a> - 1;
       this_element &gt;= 0;
       this_element--)
</pre></div>
</div>
</div>
<a class="anchor" id="ac1a3adc04ca27d22992ea483708c5812"></a><!-- doxytag: member="regex.c::group_match_null_string_p" ref="ac1a3adc04ca27d22992ea483708c5812" args="(unsigned char **p, unsigned char *end, register_info_type *reg_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex_8c.html#a330a2ea4da1ce57c189821c8ebf59618">boolean</a> group_match_null_string_p </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionregister__info__type.html">register_info_type</a> *&#160;</td>
          <td class="paramname"><em>reg_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05261">5261</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> mcnt;
  <span class="comment">/* Point to after the args to the start_memory.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p1 = *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> + 2;

  <span class="keywordflow">while</span> (p1 &lt; end)
    {
      <span class="comment">/* Skip over opcodes that can match nothing, and return true or</span>
<span class="comment">     false, as appropriate, when we get to one that can&#39;t, or to the</span>
<span class="comment">         matching stop_memory.  */</span>

      <span class="keywordflow">switch</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1)
        {
        <span class="comment">/* Could be either a loop or a series of alternatives.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>:
          p1++;
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);

          <span class="comment">/* If the next operation is not a jump backwards in the</span>
<span class="comment">         pattern.  */</span>

      <span class="keywordflow">if</span> (mcnt &gt;= 0)
        {
              <span class="comment">/* Go through the on_failure_jumps of the alternatives,</span>
<span class="comment">                 seeing if any of the alternatives cannot match nothing.</span>
<span class="comment">                 The last alternative starts with only a jump,</span>
<span class="comment">                 whereas the rest start with on_failure_jump and end</span>
<span class="comment">                 with a jump, e.g., here is the pattern for `a|b|c&#39;:</span>
<span class="comment"></span>
<span class="comment">                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6</span>
<span class="comment">                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3</span>
<span class="comment">                 /exactn/1/c</span>
<span class="comment"></span>
<span class="comment">                 So, we have to first go through the first (n-1)</span>
<span class="comment">                 alternatives and then deal with the last one separately.  */</span>


              <span class="comment">/* Deal with the first (n-1) alternatives, which start</span>
<span class="comment">                 with an on_failure_jump (see above) that jumps to right</span>
<span class="comment">                 past a jump_past_alt.  */</span>

              <span class="keywordflow">while</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[mcnt-3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>)
                {
                  <span class="comment">/* `mcnt&#39; holds how many bytes long the alternative</span>
<span class="comment">                     is, including the ending `jump_past_alt&#39; and</span>
<span class="comment">                     its number.  */</span>

                  <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a4d088a8cdab2f2daa400a5df18cbf594">alt_match_null_string_p</a> (p1, p1 + mcnt - 3,
                                      reg_info))
                    <span class="keywordflow">return</span> <span class="keyword">false</span>;

                  <span class="comment">/* Move to right after this alternative, including the</span>
<span class="comment">             jump_past_alt.  */</span>
                  p1 += mcnt;

                  <span class="comment">/* Break if it&#39;s the beginning of an n-th alternative</span>
<span class="comment">                     that doesn&#39;t begin with an on_failure_jump.  */</span>
                  <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1 != <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>)
                    <span class="keywordflow">break</span>;

          <span class="comment">/* Still have to check that it&#39;s not an n-th</span>
<span class="comment">             alternative that starts with an on_failure_jump.  */</span>
          p1++;
                  <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
                  <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[mcnt-3] != <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>)
                    {
              <span class="comment">/* Get to the beginning of the n-th alternative.  */</span>
                      p1 -= 3;
                      <span class="keywordflow">break</span>;
                    }
                }

              <span class="comment">/* Deal with the last alternative: go back and get number</span>
<span class="comment">                 of the `jump_past_alt&#39; just before it.  `mcnt&#39; contains</span>
<span class="comment">                 the length of the alternative.  */</span>
              <a class="code" href="regex_8c.html#a9afddc5990335682b1958801af7e4bf3">EXTRACT_NUMBER</a> (mcnt, p1 - 2);

              <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a4d088a8cdab2f2daa400a5df18cbf594">alt_match_null_string_p</a> (p1, p1 + mcnt, reg_info))
                <span class="keywordflow">return</span> <span class="keyword">false</span>;

              p1 += mcnt;   <span class="comment">/* Get past the n-th alternative.  */</span>
            } <span class="comment">/* if mcnt &gt; 0 */</span>
          <span class="keywordflow">break</span>;


        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>:
      <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (p1[1] == **<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>);
          *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> = p1 + 2;
          <span class="keywordflow">return</span> <span class="keyword">true</span>;


        <span class="keywordflow">default</span>:
          <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a97ff784b1a6ed91bbc1013a3a44a05da">common_op_match_null_string_p</a> (&amp;p1, end, reg_info))
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
</pre></div>
</div>
</div>
<a class="anchor" id="a74a93df5c6415ecc4c83d7497bb52a9b"></a><!-- doxytag: member="regex.c::init_syntax_once" ref="a74a93df5c6415ecc4c83d7497bb52a9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void init_syntax_once </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00183">183</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="keyword">register</span> <span class="keywordtype">int</span> c;
   <span class="keyword">static</span> <span class="keywordtype">int</span> done;

   <span class="keywordflow">if</span> (done)
     <span class="keywordflow">return</span>;

   memset (<a class="code" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>);

   <span class="keywordflow">for</span> (c = <span class="charliteral">&#39;a&#39;</span>; c &lt;= <span class="charliteral">&#39;z&#39;</span>; c++)
     <a class="code" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[c] = <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>;

   <span class="keywordflow">for</span> (c = <span class="charliteral">&#39;A&#39;</span>; c &lt;= <span class="charliteral">&#39;Z&#39;</span>; c++)
     <a class="code" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[c] = <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>;

   <span class="keywordflow">for</span> (c = <span class="charliteral">&#39;0&#39;</span>; c &lt;= <span class="charliteral">&#39;9&#39;</span>; c++)
     <a class="code" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[c] = <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>;

   <a class="code" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[<span class="charliteral">&#39;_&#39;</span>] = <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>;

   done = 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ec9fc1db02e8f3a1625ed9771f5bd92"></a><!-- doxytag: member="regex.c::insert_op1" ref="a6ec9fc1db02e8f3a1625ed9771f5bd92" args="(re_opcode_t op, unsigned char *loc, int arg, unsigned char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void insert_op1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03023">3023</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pfrom = end;
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pto = end + 3;

</pre></div>
</div>
</div>
<a class="anchor" id="ae31b1d009dfa3a2b5eca3f11ec3dee6a"></a><!-- doxytag: member="regex.c::insert_op2" ref="ae31b1d009dfa3a2b5eca3f11ec3dee6a" args="(re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void insert_op2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03042">3042</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pfrom = end;
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pto = end + 5;

</pre></div>
</div>
</div>
<a class="anchor" id="ab7e36af3707843f77cc5b4e831c2fa6d"></a><!-- doxytag: member="regex.c::malloc" ref="ab7e36af3707843f77cc5b4e831c2fa6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* malloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad21fe3ef4b1cd3a5879356dd6dc1a279"></a><!-- doxytag: member="regex.c::PARAMS" ref="ad21fe3ef4b1cd3a5879356dd6dc1a279" args="((struct re_pattern_buffer *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct re_registers *regs, int stop))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int re_match_2_internal PARAMS </td>
          <td>(</td>
          <td class="paramtype">(struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct <a class="el" href="structre__registers.html">re_registers</a> *regs, int stop)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a39979f3b79c423214dc96b34996424a8"></a><!-- doxytag: member="regex.c::re_compile_fastmap" ref="a39979f3b79c423214dc96b34996424a8" args="(struct re_pattern_buffer *bufp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int re_compile_fastmap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03191">3191</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="spgrid_8c.html#a7113d77fc628f14d4e7d1262969c613e">j</a>, <a class="code" href="spgrid_8c.html#a166d56cfd4c4c4d27db0bd3cd0fe81d9">k</a>;
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE</span>
<span class="preprocessor"></span>  <a class="code" href="structfail__stack__type.html">fail_stack_type</a> fail_stack;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#ifndef REGEX_MALLOC</span>
<span class="preprocessor"></span>  <span class="keywordtype">char</span> *destination;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="keyword">register</span> <span class="keywordtype">char</span> *fastmap = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a>;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pattern = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> = pattern;
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pend = pattern + bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a>;

<span class="preprocessor">#ifdef REL_ALLOC</span>
<span class="preprocessor"></span>  <span class="comment">/* This holds the pointer to the failure stack, when</span>
<span class="comment">     it is allocated relocatably.  */</span>
  <a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *failure_stack_ptr;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="comment">/* Assume that each path through the pattern can be null until</span>
<span class="comment">     proven otherwise.  We set this false at the bottom of switch</span>
<span class="comment">     statement, to which we get only if a particular path doesn&#39;t</span>
<span class="comment">     match the empty string.  */</span>
  <span class="keywordtype">boolean</span> path_can_be_null = <span class="keyword">true</span>;

  <span class="comment">/* We aren&#39;t doing a `succeed_n&#39; to begin with.  */</span>
  <span class="keywordtype">boolean</span> succeed_n_p = <span class="keyword">false</span>;

  <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (fastmap != <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; p != <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);

  <a class="code" href="regex_8c.html#a0a97c6a1ac97ed1288cb47dceabc56df">INIT_FAIL_STACK</a> ();
  memset (fastmap, 0, 1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>);  <span class="comment">/* Assume nothing&#39;s valid.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a837b026312b860e5485da6240b10d8f7">fastmap_accurate</a> = 1;       <span class="comment">/* It will be when we&#39;re done.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a> = 0;

  <span class="keywordflow">while</span> (1)
    {
      <span class="keywordflow">if</span> (p == pend || *p == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9">succeed</a>)
    {
      <span class="comment">/* We have reached the (effective) end of pattern.  */</span>
      <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a222a4648230cba6a1801e51b4e2ced77">FAIL_STACK_EMPTY</a> ())
        {
          bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a> |= path_can_be_null;

          <span class="comment">/* Reset for next path.  */</span>
          path_can_be_null = <span class="keyword">true</span>;

          p = fail_stack.<a class="code" href="structfail__stack__type.html#a810ddd6610b10fddebcfbf675f7800c8">stack</a>[--fail_stack.<a class="code" href="structfail__stack__type.html#a1e3d4256deebf37a4528f58d3d261854">avail</a>].<a class="code" href="unionfail__stack__elt.html#ae38105ebed00410e3185ad89ca1d6877">pointer</a>;

          <span class="keywordflow">continue</span>;
        }
      <span class="keywordflow">else</span>
        <span class="keywordflow">break</span>;
    }

      <span class="comment">/* We should never be about to go beyond the end of the pattern.  */</span>
      <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (p &lt; pend);

      <span class="keywordflow">switch</span> (<a class="code" href="regex_8c.html#a95cf7f68f7a75751d4abd454d6add11a">SWITCH_ENUM_CAST</a> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p++))
    {

        <span class="comment">/* I guess the idea here is to simply not bother with a fastmap</span>
<span class="comment">           if a backreference is used, since it&#39;s too hard to figure out</span>
<span class="comment">           the fastmap for the corresponding group.  Setting</span>
<span class="comment">           `can_be_null&#39; stops `re_search_2&#39; from using the fastmap, so</span>
<span class="comment">           that is all we do.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de">duplicate</a>:
      bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a> = 1;
          <span class="keywordflow">goto</span> done;


      <span class="comment">/* Following are the cases which match a character.  These end</span>
<span class="comment">         with `break&#39;.  */</span>

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>:
          fastmap[p[1]] = 1;
      <span class="keywordflow">break</span>;


        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>:
          <span class="keywordflow">for</span> (j = *p++ * <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a> - 1; j &gt;= 0; j--)
        <span class="keywordflow">if</span> (p[j / <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>] &amp; (1 &lt;&lt; (j % <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>)))
              fastmap[<a class="code" href="spgrid_8c.html#a7113d77fc628f14d4e7d1262969c613e">j</a>] = 1;
      <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>:
      <span class="comment">/* Chars beyond end of map must be allowed.  */</span>
      <span class="keywordflow">for</span> (j = *p * BYTEWIDTH; j &lt; (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>); j++)
            fastmap[j] = 1;

      <span class="keywordflow">for</span> (j = *p++ * BYTEWIDTH - 1; j &gt;= 0; j--)
        <span class="keywordflow">if</span> (!(p[j / BYTEWIDTH] &amp; (1 &lt;&lt; (j % BYTEWIDTH))))
              fastmap[j] = 1;
          <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b">wordchar</a>:
      <span class="keywordflow">for</span> (j = 0; j &lt; (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>); j++)
        <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> (j) == <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>)
          fastmap[j] = 1;
      <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93">notwordchar</a>:
      <span class="keywordflow">for</span> (j = 0; j &lt; (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>); j++)
        <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> (j) != <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>)
          fastmap[j] = 1;
      <span class="keywordflow">break</span>;


        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648">anychar</a>:
      {
        <span class="keywordtype">int</span> fastmap_newline = fastmap[<span class="charliteral">&#39;\n&#39;</span>];

        <span class="comment">/* `.&#39; matches anything ...  */</span>
        <span class="keywordflow">for</span> (j = 0; j &lt; (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>); j++)
          fastmap[j] = 1;

        <span class="comment">/* ... except perhaps newline.  */</span>
        <span class="keywordflow">if</span> (!(bufp-&gt;<a class="code" href="structre__pattern__buffer.html#aa16e95a1befa7d5fd8eb89542fa065f8">syntax</a> &amp; <a class="code" href="regex-gnu_8h.html#a405fe43871f2df60407b3c8272f4624c">RE_DOT_NEWLINE</a>))
          fastmap[<span class="charliteral">&#39;\n&#39;</span>] = fastmap_newline;

        <span class="comment">/* Return if we have already set `can_be_null&#39;; if we have,</span>
<span class="comment">           then the fastmap is irrelevant.  Something&#39;s wrong here.  */</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a>)
          <span class="keywordflow">goto</span> done;

        <span class="comment">/* Otherwise, have to check alternative paths.  */</span>
        <span class="keywordflow">break</span>;
      }

<span class="preprocessor">#ifdef emacs</span>
<span class="preprocessor"></span>        <span class="keywordflow">case</span> syntaxspec:
      k = *p++;
      <span class="keywordflow">for</span> (j = 0; j &lt; (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>); j++)
        <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> (j) == (<span class="keyword">enum</span> syntaxcode) k)
          fastmap[<a class="code" href="spgrid_8c.html#a7113d77fc628f14d4e7d1262969c613e">j</a>] = 1;
      <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> notsyntaxspec:
      k = *p++;
      <span class="keywordflow">for</span> (j = 0; j &lt; (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>); j++)
        <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> (j) != (<span class="keyword">enum</span> syntaxcode) k)
          fastmap[<a class="code" href="spgrid_8c.html#a7113d77fc628f14d4e7d1262969c613e">j</a>] = 1;
      <span class="keywordflow">break</span>;


      <span class="comment">/* All cases after this match the empty string.  These end with</span>
<span class="comment">         `continue&#39;.  */</span>


    <span class="keywordflow">case</span> before_dot:
    <span class="keywordflow">case</span> at_dot:
    <span class="keywordflow">case</span> after_dot:
          <span class="keywordflow">continue</span>;
<span class="preprocessor">#endif </span><span class="comment">/* emacs */</span>


        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775">endbuf</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18">wordbeg</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac">wordend</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f">push_dummy_failure</a>:
          <span class="keywordflow">continue</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>:
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (j, p);
      p += <a class="code" href="spgrid_8c.html#a7113d77fc628f14d4e7d1262969c613e">j</a>;
      <span class="keywordflow">if</span> (j &gt; 0)
        <span class="keywordflow">continue</span>;

          <span class="comment">/* Jump backward implies we just went through the body of a</span>
<span class="comment">             loop and matched nothing.  Opcode jumped to should be</span>
<span class="comment">             `on_failure_jump&#39; or `succeed_n&#39;.  Just treat it like an</span>
<span class="comment">             ordinary jump.  For a * loop, it has pushed its failure</span>
<span class="comment">             point already; if so, discard that as redundant.  */</span>
          <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p != <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>
          &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p != <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>)
        <span class="keywordflow">continue</span>;

          p++;
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (j, p);
          p += <a class="code" href="spgrid_8c.html#a7113d77fc628f14d4e7d1262969c613e">j</a>;

          <span class="comment">/* If what&#39;s on the stack is where we are now, pop it.  */</span>
          <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a222a4648230cba6a1801e51b4e2ced77">FAIL_STACK_EMPTY</a> ()
          &amp;&amp; fail_stack.<a class="code" href="structfail__stack__type.html#a810ddd6610b10fddebcfbf675f7800c8">stack</a>[fail_stack.<a class="code" href="structfail__stack__type.html#a1e3d4256deebf37a4528f58d3d261854">avail</a> - 1].<a class="code" href="unionfail__stack__elt.html#ae38105ebed00410e3185ad89ca1d6877">pointer</a> == p)
            fail_stack.<a class="code" href="structfail__stack__type.html#a1e3d4256deebf37a4528f58d3d261854">avail</a>--;

          <span class="keywordflow">continue</span>;


        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b">on_failure_keep_string_jump</a>:
    handle_on_failure_jump:
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (j, p);

          <span class="comment">/* For some patterns, e.g., `(a?)?&#39;, `p+j&#39; here points to the</span>
<span class="comment">             end of the pattern.  We don&#39;t want to push such a point,</span>
<span class="comment">             since when we restore it above, entering the switch will</span>
<span class="comment">             increment `p&#39; past the end of the pattern.  We don&#39;t need</span>
<span class="comment">             to push such a point since we obviously won&#39;t find any more</span>
<span class="comment">             fastmap entries beyond `pend&#39;.  Such a pattern can match</span>
<span class="comment">             the null string, though.  */</span>
          <span class="keywordflow">if</span> (p + j &lt; pend)
            {
              <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a78ae8e3bdec768f7fd9a75b31109fa8d">PUSH_PATTERN_OP</a> (p + j, fail_stack))
        {
          <a class="code" href="regex_8c.html#af9f8d0785dfac45a23d8d8fdb4df1629">RESET_FAIL_STACK</a> ();
          <span class="keywordflow">return</span> -2;
        }
            }
          <span class="keywordflow">else</span>
            bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a> = 1;

          <span class="keywordflow">if</span> (succeed_n_p)
            {
              <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (k, p);   <span class="comment">/* Skip the n.  */</span>
              succeed_n_p = <span class="keyword">false</span>;
        }

          <span class="keywordflow">continue</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>:
          <span class="comment">/* Get to the number of times to succeed.  */</span>
          p += 2;

          <span class="comment">/* Increment p past the n for when k != 0.  */</span>
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (k, p);
          <span class="keywordflow">if</span> (k == 0)
        {
              p -= 4;
          succeed_n_p = <span class="keyword">true</span>;  <span class="comment">/* Spaghetti code alert.  */</span>
              <span class="keywordflow">goto</span> handle_on_failure_jump;
            }
          <span class="keywordflow">continue</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>:
          p += 4;
          <span class="keywordflow">continue</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>:
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>:
      p += 2;
      <span class="keywordflow">continue</span>;


    <span class="keywordflow">default</span>:
          abort (); <span class="comment">/* We have listed all the cases.  */</span>
        } <span class="comment">/* switch *p++ */</span>

      <span class="comment">/* Getting here means we have found the possible starting</span>
<span class="comment">         characters for one path of the pattern -- and that the empty</span>
<span class="comment">         string does not match.  We need not follow this path further.</span>
<span class="comment">         Instead, look at the next alternative (remembered on the</span>
<span class="comment">         stack), or quit if no more.  The test at the top of the loop</span>
<span class="comment">         does these things.  */</span>
      path_can_be_null = <span class="keyword">false</span>;
      p = pend;
    } <span class="comment">/* while p */</span>

  <span class="comment">/* Set `can_be_null&#39; for the last path (also the first path, if the</span>
<span class="comment">     pattern is empty).  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a> |= path_can_be_null;
</pre></div>
</div>
</div>
<a class="anchor" id="af8f972d3f97fde09a38ee8f8e204b6c3"></a><!-- doxytag: member="regex.c::re_compile_pattern" ref="af8f972d3f97fde09a38ee8f8e204b6c3" args="(char *pattern, size_t length, struct re_pattern_buffer *bufp) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* re_compile_pattern </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05522">5522</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> ret;

  <span class="comment">/* GNU code is written to assume at least RE_NREGS registers will be set</span>
<span class="comment">     (and at least one extra will be -1).  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83388321c434be6ac33fe359a3d7b449">regs_allocated</a> = <a class="code" href="regex-gnu_8h.html#a2714d3e1903c4824ef31ccae36e702c7">REGS_UNALLOCATED</a>;

  <span class="comment">/* And GNU code determines whether or not to get register information</span>
<span class="comment">     by passing null for the REGS argument to re_match, etc., not by</span>
<span class="comment">     setting no_sub.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83e122c96edb258aa4ef99d7a8b2bfa2">no_sub</a> = 0;

  <span class="comment">/* Match anchors at newline.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a> = 1;

  ret = <a class="code" href="regex_8c.html#a6a04e18fe89cacd4b8d04a474def5985">regex_compile</a> (pattern, <a class="code" href="isis__pdu_8h.html#a64ed70bbcb4536e2af22a1aaf5209d18">length</a>, <a class="code" href="regex-gnu_8h.html#abdc5e67bbb6a48b740a95aef2bc3f5f2">re_syntax_options</a>, bufp);
</pre></div>
</div>
</div>
<a class="anchor" id="a543f20720a243ca31e0667b697de3bda"></a><!-- doxytag: member="regex.c::re_match" ref="a543f20720a243ca31e0667b697de3bda" args="(struct re_pattern_buffer *bufp, const char *string, int size, int pos, struct re_registers *regs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int re_match </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__registers.html">re_registers</a> *&#160;</td>
          <td class="paramname"><em>regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03788">3788</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> result = <a class="code" href="regex_8c.html#a3b426565d92028a1cf7113fcf41942c8">re_match_2_internal</a> (bufp, <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0, <span class="keywordtype">string</span>, size,
                    pos, regs, size);
<span class="preprocessor"># ifndef REGEX_MALLOC</span>
<span class="preprocessor"></span><span class="preprocessor">#  ifdef C_ALLOCA</span>
</pre></div>
</div>
</div>
<a class="anchor" id="ae4aacc367337cbfc7513b4be57808b78"></a><!-- doxytag: member="regex.c::re_match_2" ref="ae4aacc367337cbfc7513b4be57808b78" args="(struct re_pattern_buffer *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct re_registers *regs, int stop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int re_match_2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__registers.html">re_registers</a> *&#160;</td>
          <td class="paramname"><em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03834">3834</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> result = <a class="code" href="regex_8c.html#a3b426565d92028a1cf7113fcf41942c8">re_match_2_internal</a> (bufp, string1, size1, string2, size2,
                    pos, regs, stop);
<span class="preprocessor">#ifndef REGEX_MALLOC</span>
<span class="preprocessor"></span><span class="preprocessor"># ifdef C_ALLOCA</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a3b426565d92028a1cf7113fcf41942c8"></a><!-- doxytag: member="regex.c::re_match_2_internal" ref="a3b426565d92028a1cf7113fcf41942c8" args="(struct re_pattern_buffer *bufp, const char *string1, int size1, const char *string2, int size2, int pos, struct re_registers *regs, int stop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int re_match_2_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__registers.html">re_registers</a> *&#160;</td>
          <td class="paramname"><em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03858">3858</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">/* General temporaries.  */</span>
  <span class="keywordtype">int</span> mcnt;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p1;

  <span class="comment">/* Just past the end of the corresponding string.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *end1, *end2;

  <span class="comment">/* Pointers into string1 and string2, just past the last characters in</span>
<span class="comment">     each to consider matching.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *end_match_1, *end_match_2;

  <span class="comment">/* Where we are in the data, and the end of the current string.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *d, *dend;

  <span class="comment">/* Where we are in the pattern, and the end of the pattern.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>;
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pend = p + bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a>;

  <span class="comment">/* Mark the opcode just after a start_memory, so we can test for an</span>
<span class="comment">     empty subpattern when we get to the stop_memory.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *just_past_start_mem = 0;

  <span class="comment">/* We use this to map every character in the string.  */</span>
  <a class="code" href="regex-gnu_8h.html#a96c9fb9c7074cb21740b63092b0637a4">RE_TRANSLATE_TYPE</a> translate = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a>;

  <span class="comment">/* Failure point stack.  Each place that can handle a failure further</span>
<span class="comment">     down the line pushes a failure point on this stack.  It consists of</span>
<span class="comment">     restart, regend, and reg_info for all registers corresponding to</span>
<span class="comment">     the subexpressions we&#39;re currently inside, plus the number of such</span>
<span class="comment">     registers, and, finally, two char *&#39;s.  The first char * is where</span>
<span class="comment">     to resume scanning the pattern; the second one is where to resume</span>
<span class="comment">     scanning the strings.  If the latter is zero, the failure point is</span>
<span class="comment">     a ``dummy&#39;&#39;; if a failure happens and the failure point is a dummy,</span>
<span class="comment">     it gets discarded and the next next one is tried.  */</span>
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE </span><span class="comment">/* otherwise, this is global.  */</span>
  <a class="code" href="structfail__stack__type.html">fail_stack_type</a> fail_stack;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#ifdef DEBUG</span>
<span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> failure_id;
  <span class="keywordtype">unsigned</span> nfailure_points_pushed = 0, nfailure_points_popped = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef REL_ALLOC</span>
<span class="preprocessor"></span>  <span class="comment">/* This holds the pointer to the failure stack, when</span>
<span class="comment">     it is allocated relocatably.  */</span>
  <a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *failure_stack_ptr;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="comment">/* We fill all the registers internally, independent of what we</span>
<span class="comment">     return, for use in backreferences.  The number here includes</span>
<span class="comment">     an element for register zero.  */</span>
  <span class="keywordtype">size_t</span> num_regs = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a703c2069a09bac7fa67de8871cb17d35">re_nsub</a> + 1;

  <span class="comment">/* The currently active registers.  */</span>
  <a class="code" href="regex-gnu_8h.html#ab64c4b3b9990d5c9e7e30219aecec37a">active_reg_t</a> lowest_active_reg = <a class="code" href="regex_8c.html#a508c8adae6628ee43b8498249272efb9">NO_LOWEST_ACTIVE_REG</a>;
  <a class="code" href="regex-gnu_8h.html#ab64c4b3b9990d5c9e7e30219aecec37a">active_reg_t</a> highest_active_reg = <a class="code" href="regex_8c.html#ab79c167c4cd771eeb9f88cf07c8b66c2">NO_HIGHEST_ACTIVE_REG</a>;

  <span class="comment">/* Information on the contents of registers. These are pointers into</span>
<span class="comment">     the input strings; they record just what was matched (on this</span>
<span class="comment">     attempt) by a subexpression part of the pattern, that is, the</span>
<span class="comment">     regnum-th regstart pointer points to where in the pattern we began</span>
<span class="comment">     matching and the regnum-th regend points to right after where we</span>
<span class="comment">     stopped matching the regnum-th subexpression.  (The zeroth register</span>
<span class="comment">     keeps track of what the whole pattern matches.)  */</span>
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE </span><span class="comment">/* otherwise, these are global.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> **regstart, **regend;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="comment">/* If a group that&#39;s operated upon by a repetition operator fails to</span>
<span class="comment">     match anything, then the register for its start will need to be</span>
<span class="comment">     restored because it will have been set to wherever in the string we</span>
<span class="comment">     are when we last see its open-group operator.  Similarly for a</span>
<span class="comment">     register&#39;s end.  */</span>
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE </span><span class="comment">/* otherwise, these are global.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> **old_regstart, **old_regend;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="comment">/* The is_active field of reg_info helps us keep track of which (possibly</span>
<span class="comment">     nested) subexpressions we are currently in. The matched_something</span>
<span class="comment">     field of reg_info[reg_num] helps us tell whether or not we have</span>
<span class="comment">     matched any of the pattern so far this time through the reg_num-th</span>
<span class="comment">     subexpression.  These two fields get reset each time through any</span>
<span class="comment">     loop their register is in.  */</span>
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE </span><span class="comment">/* otherwise, this is global.  */</span>
  <a class="code" href="unionregister__info__type.html">register_info_type</a> *reg_info;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="comment">/* The following record the register info as found in the above</span>
<span class="comment">     variables when we find a match better than any we&#39;ve seen before.</span>
<span class="comment">     This happens as we backtrack through the failure points, which in</span>
<span class="comment">     turn happens only if we have not yet matched the entire string. */</span>
  <span class="keywordtype">unsigned</span> best_regs_set = <span class="keyword">false</span>;
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE </span><span class="comment">/* otherwise, these are global.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> **best_regstart, **best_regend;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="comment">/* Logically, this is `best_regend[0]&#39;.  But we don&#39;t want to have to</span>
<span class="comment">     allocate space for that if we&#39;re not allocating space for anything</span>
<span class="comment">     else (see below).  Also, we never need info about register 0 for</span>
<span class="comment">     any of the other register vectors, and it seems rather a kludge to</span>
<span class="comment">     treat `best_regend&#39; differently than the rest.  So we keep track of</span>
<span class="comment">     the end of the best match so far in a separate variable.  We</span>
<span class="comment">     initialize this to NULL so that when we backtrack the first time</span>
<span class="comment">     and need to test it, it&#39;s not garbage.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *match_end = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;

  <span class="comment">/* This helps SET_REGS_MATCHED avoid doing redundant work.  */</span>
  <span class="keywordtype">int</span> set_regs_matched_done = 0;

  <span class="comment">/* Used when we pop values we don&#39;t care about.  */</span>
<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE </span><span class="comment">/* otherwise, these are global.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> **reg_dummy;
  <a class="code" href="unionregister__info__type.html">register_info_type</a> *reg_info_dummy;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef DEBUG</span>
<span class="preprocessor"></span>  <span class="comment">/* Counts the total number of registers pushed.  */</span>
  <span class="keywordtype">unsigned</span> num_regs_pushed = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;\n\nEntering re_match_2.\n&quot;</span>);

  <a class="code" href="regex_8c.html#a0a97c6a1ac97ed1288cb47dceabc56df">INIT_FAIL_STACK</a> ();

<span class="preprocessor">#ifdef MATCH_MAY_ALLOCATE</span>
<span class="preprocessor"></span>  <span class="comment">/* Do not bother to initialize all the register variables if there are</span>
<span class="comment">     no groups in the pattern, as it takes a fair amount of time.  If</span>
<span class="comment">     there are groups, we include space for register 0 (the whole</span>
<span class="comment">     pattern), even though we never use it, since it simplifies the</span>
<span class="comment">     array indexing.  We should fix this.  */</span>
  <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a703c2069a09bac7fa67de8871cb17d35">re_nsub</a>)
    {
      regstart = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      regend = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      old_regstart = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      old_regend = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      best_regstart = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      best_regend = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      reg_info = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <a class="code" href="unionregister__info__type.html">register_info_type</a>);
      reg_dummy = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
      reg_info_dummy = <a class="code" href="regex_8c.html#aa55c07b38a55837693a65170c5aa4c76">REGEX_TALLOC</a> (num_regs, <a class="code" href="unionregister__info__type.html">register_info_type</a>);

      <span class="keywordflow">if</span> (!(regstart &amp;&amp; regend &amp;&amp; old_regstart &amp;&amp; old_regend &amp;&amp; reg_info
            &amp;&amp; best_regstart &amp;&amp; best_regend &amp;&amp; reg_dummy &amp;&amp; reg_info_dummy))
        {
          <a class="code" href="regex_8c.html#a7f3f2410fe2ae0089be0a2f3005f15dd">FREE_VARIABLES</a> ();
          <span class="keywordflow">return</span> -2;
        }
    }
  <span class="keywordflow">else</span>
    {
      <span class="comment">/* We must initialize all our variables to NULL, so that</span>
<span class="comment">         `FREE_VARIABLES&#39; doesn&#39;t try to free them.  */</span>
      regstart = regend = old_regstart = old_regend = best_regstart
        = best_regend = reg_dummy = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
      reg_info = reg_info_dummy = (<a class="code" href="unionregister__info__type.html">register_info_type</a> *) <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
    }
<span class="preprocessor">#endif </span><span class="comment">/* MATCH_MAY_ALLOCATE */</span>

  <span class="comment">/* The starting position is bogus.  */</span>
  <span class="keywordflow">if</span> (pos &lt; 0 || pos &gt; size1 + size2)
    {
      <a class="code" href="regex_8c.html#a7f3f2410fe2ae0089be0a2f3005f15dd">FREE_VARIABLES</a> ();
      <span class="keywordflow">return</span> -1;
    }

  <span class="comment">/* Initialize subexpression text positions to -1 to mark ones that no</span>
<span class="comment">     start_memory/stop_memory has been seen for. Also initialize the</span>
<span class="comment">     register information struct.  */</span>
  <span class="keywordflow">for</span> (mcnt = 1; (unsigned) mcnt &lt; num_regs; mcnt++)
    {
      regstart[mcnt] = regend[mcnt]
        = old_regstart[mcnt] = old_regend[mcnt] = <a class="code" href="regex_8c.html#a78d7e87774e3c9ae84570f8ab88f55a5">REG_UNSET_VALUE</a>;

      <a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[mcnt]) = <a class="code" href="regex_8c.html#a9fbdd9b78059994c85d9f064f9fa9ec3">MATCH_NULL_UNSET_VALUE</a>;
      <a class="code" href="regex_8c.html#a4f6628b4b02e356efb3c4c8e6cf8eaff">IS_ACTIVE</a> (reg_info[mcnt]) = 0;
      <a class="code" href="regex_8c.html#a37aeb4969c6ded152f5be7582330e6e5">MATCHED_SOMETHING</a> (reg_info[mcnt]) = 0;
      <a class="code" href="regex_8c.html#ad4e9639db811e6b09f31ff92466b404e">EVER_MATCHED_SOMETHING</a> (reg_info[mcnt]) = 0;
    }

  <span class="comment">/* We move `string1&#39; into `string2&#39; if the latter&#39;s empty -- but not if</span>
<span class="comment">     `string1&#39; is null.  */</span>
  <span class="keywordflow">if</span> (size2 == 0 &amp;&amp; string1 != <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    {
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
    }
  end1 = string1 + size1;
  end2 = string2 + size2;

  <span class="comment">/* Compute where to stop matching, within the two strings.  */</span>
  <span class="keywordflow">if</span> (stop &lt;= size1)
    {
      end_match_1 = string1 + stop;
      end_match_2 = string2;
    }
  <span class="keywordflow">else</span>
    {
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
    }

  <span class="comment">/* `p&#39; scans through the pattern as `d&#39; scans through the data.</span>
<span class="comment">     `dend&#39; is the end of the input string that `d&#39; points within.  `d&#39;</span>
<span class="comment">     is advanced into the following input string whenever necessary, but</span>
<span class="comment">     this happens before fetching; therefore, at the beginning of the</span>
<span class="comment">     loop, `d&#39; can be pointing at the end of a string, but it cannot</span>
<span class="comment">     equal `string2&#39;.  */</span>
  <span class="keywordflow">if</span> (size1 &gt; 0 &amp;&amp; pos &lt;= size1)
    {
      d = string1 + pos;
      dend = end_match_1;
    }
  <span class="keywordflow">else</span>
    {
      d = string2 + pos - size1;
      dend = end_match_2;
    }

  <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;The compiled pattern is:\n&quot;</span>);
  <a class="code" href="regex_8c.html#ac9718b28cdc916b46e7f98bd4c38151e">DEBUG_PRINT_COMPILED_PATTERN</a> (bufp, p, pend);
  <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;The string to match is: `&quot;</span>);
  <a class="code" href="regex_8c.html#ac98cc201be49e8dd0e1d05264e7651d7">DEBUG_PRINT_DOUBLE_STRING</a> (d, string1, size1, string2, size2);
  <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;&#39;\n&quot;</span>);

  <span class="comment">/* This loops over pattern commands.  It exits by returning from the</span>
<span class="comment">     function if the match is complete, or it drops through if the match</span>
<span class="comment">     fails at this starting point in the input data.  */</span>
  <span class="keywordflow">for</span> (;;)
    {
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;\n%p: &quot;</span>, p);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;\n0x%x: &quot;</span>, p);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
      <span class="keywordflow">if</span> (p == pend)
    { <span class="comment">/* End of pattern means we might have succeeded.  */</span>
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;end of pattern ... &quot;</span>);

      <span class="comment">/* If we haven&#39;t matched the entire string, and we want the</span>
<span class="comment">             longest match, try backtracking.  */</span>
          <span class="keywordflow">if</span> (d != end_match_2)
        {
          <span class="comment">/* 1 if this match ends in the same string (string1 or string2)</span>
<span class="comment">         as the best previous match.  */</span>
          <span class="keywordtype">boolean</span> same_str_p = (<a class="code" href="regex_8c.html#a490c47f87b80eb6afdb77510567659e4">FIRST_STRING_P</a> (match_end)
                    == <a class="code" href="regex_8c.html#a7c5c8716cb01b2ad2cb50732817cbe4d">MATCHING_IN_FIRST_STRING</a>);
          <span class="comment">/* 1 if this match is the best seen so far.  */</span>
          <span class="keywordtype">boolean</span> best_match_p;

          <span class="comment">/* AIX compiler got confused when this was combined</span>
<span class="comment">         with the previous declaration.  */</span>
          <span class="keywordflow">if</span> (same_str_p)
        best_match_p = d &gt; match_end;
          <span class="keywordflow">else</span>
        best_match_p = !<a class="code" href="regex_8c.html#a7c5c8716cb01b2ad2cb50732817cbe4d">MATCHING_IN_FIRST_STRING</a>;

              <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;backtracking.\n&quot;</span>);

              <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a222a4648230cba6a1801e51b4e2ced77">FAIL_STACK_EMPTY</a> ())
                { <span class="comment">/* More failure points to try.  */</span>

                  <span class="comment">/* If exceeds best match so far, save it.  */</span>
                  <span class="keywordflow">if</span> (!best_regs_set || best_match_p)
                    {
                      best_regs_set = <span class="keyword">true</span>;
                      match_end = d;

                      <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;\nSAVING match as best so far.\n&quot;</span>);

                      <span class="keywordflow">for</span> (mcnt = 1; (unsigned) mcnt &lt; num_regs; mcnt++)
                        {
                          best_regstart[mcnt] = regstart[mcnt];
                          best_regend[mcnt] = regend[mcnt];
                        }
                    }
                  <span class="keywordflow">goto</span> fail;
                }

              <span class="comment">/* If no failure points, don&#39;t restore garbage.  And if</span>
<span class="comment">                 last match is real best match, don&#39;t restore second</span>
<span class="comment">                 best one. */</span>
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (best_regs_set &amp;&amp; !best_match_p)
                {
            restore_best_regs:
                  <span class="comment">/* Restore best match.  It may happen that `dend ==</span>
<span class="comment">                     end_match_1&#39; while the restored d is in string2.</span>
<span class="comment">                     For example, the pattern `x.*y.*z&#39; against the</span>
<span class="comment">                     strings `x-&#39; and `y-z-&#39;, if the two strings are</span>
<span class="comment">                     not consecutive in memory.  */</span>
                  <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;Restoring best registers.\n&quot;</span>);

                  d = match_end;
                  dend = ((d &gt;= string1 &amp;&amp; d &lt;= end1)
                   ? end_match_1 : end_match_2);

          <span class="keywordflow">for</span> (mcnt = 1; (unsigned) mcnt &lt; num_regs; mcnt++)
            {
              regstart[mcnt] = best_regstart[mcnt];
              regend[mcnt] = best_regend[mcnt];
            }
                }
            } <span class="comment">/* d != end_match_2 */</span>

    succeed_label:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;Accepting match.\n&quot;</span>);

          <span class="comment">/* If caller wants register contents data back, do it.  */</span>
          <span class="keywordflow">if</span> (regs &amp;&amp; !bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83e122c96edb258aa4ef99d7a8b2bfa2">no_sub</a>)
        {
              <span class="comment">/* Have the register data arrays been allocated?  */</span>
              <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83388321c434be6ac33fe359a3d7b449">regs_allocated</a> == <a class="code" href="regex-gnu_8h.html#a2714d3e1903c4824ef31ccae36e702c7">REGS_UNALLOCATED</a>)
                { <span class="comment">/* No.  So allocate them with malloc.  We need one</span>
<span class="comment">                     extra element beyond `num_regs&#39; for the `-1&#39; marker</span>
<span class="comment">                     GNU code uses.  */</span>
                  regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a> = <a class="code" href="regex_8c.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a> (<a class="code" href="regex-gnu_8h.html#a36fa5b4c2430ba987abcc9a0d60ba37e">RE_NREGS</a>, num_regs + 1);
                  regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a> = <a class="code" href="regex_8c.html#aaf77bcbd178f50762a35333d83bacd09">TALLOC</a> (regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a>, <a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>);
                  regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a> = <a class="code" href="regex_8c.html#aaf77bcbd178f50762a35333d83bacd09">TALLOC</a> (regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a>, <a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>);
                  <span class="keywordflow">if</span> (regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
            {
              <a class="code" href="regex_8c.html#a7f3f2410fe2ae0089be0a2f3005f15dd">FREE_VARIABLES</a> ();
              <span class="keywordflow">return</span> -2;
            }
                  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83388321c434be6ac33fe359a3d7b449">regs_allocated</a> = <a class="code" href="regex-gnu_8h.html#a87642301f41c9c37e7f4d10ab5ade987">REGS_REALLOCATE</a>;
                }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83388321c434be6ac33fe359a3d7b449">regs_allocated</a> == <a class="code" href="regex-gnu_8h.html#a87642301f41c9c37e7f4d10ab5ade987">REGS_REALLOCATE</a>)
                { <span class="comment">/* Yes.  If we need more elements than were already</span>
<span class="comment">                     allocated, reallocate them.  If we need fewer, just</span>
<span class="comment">                     leave it alone.  */</span>
                  <span class="keywordflow">if</span> (regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a> &lt; num_regs + 1)
                    {
                      regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a> = num_regs + 1;
                      <a class="code" href="regex_8c.html#ae247cb248fa0309737dce6bdfc3a6a3d">RETALLOC</a> (regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a>, regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a>, <a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>);
                      <a class="code" href="regex_8c.html#ae247cb248fa0309737dce6bdfc3a6a3d">RETALLOC</a> (regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a>, regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a>, <a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>);
                      <span class="keywordflow">if</span> (regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
            {
              <a class="code" href="regex_8c.html#a7f3f2410fe2ae0089be0a2f3005f15dd">FREE_VARIABLES</a> ();
              <span class="keywordflow">return</span> -2;
            }
                    }
                }
              <span class="keywordflow">else</span>
        {
          <span class="comment">/* These braces fend off a &quot;empty body in an else-statement&quot;</span>
<span class="comment">             warning under GCC when assert expands to nothing.  */</span>
          <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83388321c434be6ac33fe359a3d7b449">regs_allocated</a> == <a class="code" href="regex-gnu_8h.html#a54c8820fca418980dbcd43ebd78ed5a6">REGS_FIXED</a>);
        }

              <span class="comment">/* Convert the pointer data in `regstart&#39; and `regend&#39; to</span>
<span class="comment">                 indices.  Register zero has to be set differently,</span>
<span class="comment">                 since we haven&#39;t kept track of any info for it.  */</span>
              <span class="keywordflow">if</span> (regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a> &gt; 0)
                {
                  regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a>[0] = pos;
                  regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a>[0] = (<a class="code" href="regex_8c.html#a7c5c8716cb01b2ad2cb50732817cbe4d">MATCHING_IN_FIRST_STRING</a>
                  ? ((<a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>) (d - string1))
                      : ((<a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>) (d - string2 + size1)));
                }

              <span class="comment">/* Go through the first `min (num_regs, regs-&gt;num_regs)&#39;</span>
<span class="comment">                 registers, since that is all we initialized.  */</span>
          <span class="keywordflow">for</span> (mcnt = 1; (unsigned) mcnt &lt; <a class="code" href="regex_8c.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a> (num_regs, regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a>);
           mcnt++)
        {
                  <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a> (regstart[mcnt]) || <a class="code" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a> (regend[mcnt]))
                    regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a>[mcnt] = regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a>[mcnt] = -1;
                  <span class="keywordflow">else</span>
                    {
              regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a>[mcnt]
            = (<a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>) <a class="code" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a> (regstart[mcnt]);
                      regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a>[mcnt]
            = (<a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>) <a class="code" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a> (regend[mcnt]);
                    }
        }

              <span class="comment">/* If the regs structure we return has more elements than</span>
<span class="comment">                 were in the pattern, set the extra elements to -1.  If</span>
<span class="comment">                 we (re)allocated the registers, this is the case,</span>
<span class="comment">                 because we always allocate enough to have at least one</span>
<span class="comment">                 -1 at the end.  */</span>
              <span class="keywordflow">for</span> (mcnt = num_regs; (unsigned) mcnt &lt; regs-&gt;num_regs; mcnt++)
                regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a>[mcnt] = regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a>[mcnt] = -1;
        } <span class="comment">/* regs &amp;&amp; !bufp-&gt;no_sub */</span>

          <a class="code" href="regex_8c.html#aca55c7b840c46d7e72964a9ecf52310f">DEBUG_PRINT4</a> (<span class="stringliteral">&quot;%u failure points pushed, %u popped (%u remain).\n&quot;</span>,
                        nfailure_points_pushed, nfailure_points_popped,
                        nfailure_points_pushed - nfailure_points_popped);
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;%u registers pushed.\n&quot;</span>, num_regs_pushed);

          mcnt = d - pos - (<a class="code" href="regex_8c.html#a7c5c8716cb01b2ad2cb50732817cbe4d">MATCHING_IN_FIRST_STRING</a>
                ? string1
                : string2 - size1);

          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;Returning %d from re_match_2.\n&quot;</span>, mcnt);

          <a class="code" href="regex_8c.html#a7f3f2410fe2ae0089be0a2f3005f15dd">FREE_VARIABLES</a> ();
          <span class="keywordflow">return</span> mcnt;
        }

      <span class="comment">/* Otherwise match next pattern command.  */</span>
      <span class="keywordflow">switch</span> (<a class="code" href="regex_8c.html#a95cf7f68f7a75751d4abd454d6add11a">SWITCH_ENUM_CAST</a> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p++))
    {
        <span class="comment">/* Ignore these.  Used to ignore the n of succeed_n&#39;s which</span>
<span class="comment">           currently have n == 0.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING no_op.\n&quot;</span>);
          <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9">succeed</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING succeed.\n&quot;</span>);
      <span class="keywordflow">goto</span> succeed_label;

        <span class="comment">/* Match the next n pattern characters exactly.  The following</span>
<span class="comment">           byte in the pattern defines n, and the n bytes after that</span>
<span class="comment">           are the characters to match.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>:
      mcnt = *p++;
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING exactn %d.\n&quot;</span>, mcnt);

          <span class="comment">/* This is written out as an if-else so we don&#39;t waste time</span>
<span class="comment">             testing `translate&#39; inside the loop.  */</span>
          <span class="keywordflow">if</span> (translate)
        {
          <span class="keywordflow">do</span>
        {
          <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
          <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) translate[(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *d++]
              != (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *p++)
                    <span class="keywordflow">goto</span> fail;
        }
          <span class="keywordflow">while</span> (--mcnt);
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">do</span>
        {
          <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
          <span class="keywordflow">if</span> (*d++ != (<span class="keywordtype">char</span>) *p++) <span class="keywordflow">goto</span> fail;
        }
          <span class="keywordflow">while</span> (--mcnt);
        }
      <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
          <span class="keywordflow">break</span>;


        <span class="comment">/* Match any character except possibly a newline or a null.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648">anychar</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING anychar.\n&quot;</span>);

          <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();

          <span class="keywordflow">if</span> ((!(bufp-&gt;<a class="code" href="structre__pattern__buffer.html#aa16e95a1befa7d5fd8eb89542fa065f8">syntax</a> &amp; <a class="code" href="regex-gnu_8h.html#a405fe43871f2df60407b3c8272f4624c">RE_DOT_NEWLINE</a>) &amp;&amp; <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (*d) == <span class="charliteral">&#39;\n&#39;</span>)
              || (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#aa16e95a1befa7d5fd8eb89542fa065f8">syntax</a> &amp; <a class="code" href="regex-gnu_8h.html#a30d6a2fb42df1a210e830f3cd3f06977">RE_DOT_NOT_NULL</a> &amp;&amp; <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (*d) == <span class="charliteral">&#39;\000&#39;</span>))
        <span class="keywordflow">goto</span> fail;

          <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;  Matched `%d&#39;.\n&quot;</span>, *d);
          d++;
      <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>:
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>:
      {
        <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
        <span class="keywordtype">boolean</span> not = (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *(p - 1) == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>;

            <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING charset%s.\n&quot;</span>, not ? <span class="stringliteral">&quot;_not&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);

        <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
        c = <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (*d); <span class="comment">/* The character to match.  */</span>

            <span class="comment">/* Cast to `unsigned&#39; instead of `unsigned char&#39; in case the</span>
<span class="comment">               bit list is a full 32 bytes long.  */</span>
        <span class="keywordflow">if</span> (c &lt; (<span class="keywordtype">unsigned</span>) (*p * <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>)
        &amp;&amp; p[1 + c / BYTEWIDTH] &amp; (1 &lt;&lt; (c % BYTEWIDTH)))
          not = !not;

        p += 1 + *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

        <span class="keywordflow">if</span> (!not) <span class="keywordflow">goto</span> fail;

        <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
            d++;
        <span class="keywordflow">break</span>;
      }


        <span class="comment">/* The beginning of a group is represented by start_memory.</span>
<span class="comment">           The arguments are the register number in the next byte, and the</span>
<span class="comment">           number of groups inner to this one in the next.  The text</span>
<span class="comment">           matched within the group is recorded (in the internal</span>
<span class="comment">           registers data structure) under the register number.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>:
      <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;EXECUTING start_memory %d (%d):\n&quot;</span>, *p, p[1]);

          <span class="comment">/* Find out if this group can match the empty string.  */</span>
      p1 = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;       <span class="comment">/* To send to group_match_null_string_p.  */</span>

          <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[*p]) == <a class="code" href="regex_8c.html#a9fbdd9b78059994c85d9f064f9fa9ec3">MATCH_NULL_UNSET_VALUE</a>)
            <a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[*p])
              = <a class="code" href="regex_8c.html#ac1a3adc04ca27d22992ea483708c5812">group_match_null_string_p</a> (&amp;p1, pend, reg_info);

          <span class="comment">/* Save the position in the string where we were the last time</span>
<span class="comment">             we were at this open-group operator in case the group is</span>
<span class="comment">             operated upon by a repetition operator, e.g., with `(a*)*b&#39;</span>
<span class="comment">             against `ab&#39;; then we want to ignore where we are now in</span>
<span class="comment">             the string in case this attempt to match fails.  */</span>
          old_regstart[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>] = <a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[*p])
                             ? <a class="code" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a> (regstart[*p]) ? d : regstart[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>]
                             : regstart[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>];
      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;  old_regstart: %d\n&quot;</span>,
             <a class="code" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a> (old_regstart[*p]));

          regstart[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>] = d;
      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;  regstart: %d\n&quot;</span>, <a class="code" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a> (regstart[*p]));

          <a class="code" href="regex_8c.html#a4f6628b4b02e356efb3c4c8e6cf8eaff">IS_ACTIVE</a> (reg_info[*p]) = 1;
          <a class="code" href="regex_8c.html#a37aeb4969c6ded152f5be7582330e6e5">MATCHED_SOMETHING</a> (reg_info[*p]) = 0;

      <span class="comment">/* Clear this whenever we change the register activity status.  */</span>
      set_regs_matched_done = 0;

          <span class="comment">/* This is the new highest active register.  */</span>
          highest_active_reg = *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

          <span class="comment">/* If nothing was active before, this is the new lowest active</span>
<span class="comment">             register.  */</span>
          <span class="keywordflow">if</span> (lowest_active_reg == <a class="code" href="regex_8c.html#a508c8adae6628ee43b8498249272efb9">NO_LOWEST_ACTIVE_REG</a>)
            lowest_active_reg = *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

          <span class="comment">/* Move past the register number and inner group count.  */</span>
          p += 2;
      just_past_start_mem = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

          <span class="keywordflow">break</span>;


        <span class="comment">/* The stop_memory opcode represents the end of a group.  Its</span>
<span class="comment">           arguments are the same as start_memory&#39;s: the register</span>
<span class="comment">           number, and the number of inner groups.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>:
      <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;EXECUTING stop_memory %d (%d):\n&quot;</span>, *p, p[1]);

          <span class="comment">/* We need to save the string position the last time we were at</span>
<span class="comment">             this close-group operator in case the group is operated</span>
<span class="comment">             upon by a repetition operator, e.g., with `((a*)*(b*)*)*&#39;</span>
<span class="comment">             against `aba&#39;; then we want to ignore where we are now in</span>
<span class="comment">             the string in case this attempt to match fails.  */</span>
          old_regend[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>] = <a class="code" href="regex_8c.html#ac840f4f2ecf1841ed894bd361236715b">REG_MATCH_NULL_STRING_P</a> (reg_info[*p])
                           ? <a class="code" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a> (regend[*p]) ? d : regend[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>]
               : regend[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>];
      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;      old_regend: %d\n&quot;</span>,
             <a class="code" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a> (old_regend[*p]));

          regend[*<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>] = d;
      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;      regend: %d\n&quot;</span>, <a class="code" href="regex_8c.html#a8bebab7ed279441748e37304f7a2c78a">POINTER_TO_OFFSET</a> (regend[*p]));

          <span class="comment">/* This register isn&#39;t active anymore.  */</span>
          <a class="code" href="regex_8c.html#a4f6628b4b02e356efb3c4c8e6cf8eaff">IS_ACTIVE</a> (reg_info[*p]) = 0;

      <span class="comment">/* Clear this whenever we change the register activity status.  */</span>
      set_regs_matched_done = 0;

          <span class="comment">/* If this was the only register active, nothing is active</span>
<span class="comment">             anymore.  */</span>
          <span class="keywordflow">if</span> (lowest_active_reg == highest_active_reg)
            {
              lowest_active_reg = <a class="code" href="regex_8c.html#a508c8adae6628ee43b8498249272efb9">NO_LOWEST_ACTIVE_REG</a>;
              highest_active_reg = <a class="code" href="regex_8c.html#ab79c167c4cd771eeb9f88cf07c8b66c2">NO_HIGHEST_ACTIVE_REG</a>;
            }
          <span class="keywordflow">else</span>
            { <span class="comment">/* We must scan for the new highest active register, since</span>
<span class="comment">                 it isn&#39;t necessarily one less than now: consider</span>
<span class="comment">                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the</span>
<span class="comment">                 new highest active register is 1.  */</span>
              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r = *p - 1;
              <span class="keywordflow">while</span> (r &gt; 0 &amp;&amp; !<a class="code" href="regex_8c.html#a4f6628b4b02e356efb3c4c8e6cf8eaff">IS_ACTIVE</a> (reg_info[r]))
                r--;

              <span class="comment">/* If we end up at register zero, that means that we saved</span>
<span class="comment">                 the registers as the result of an `on_failure_jump&#39;, not</span>
<span class="comment">                 a `start_memory&#39;, and we jumped to past the innermost</span>
<span class="comment">                 `stop_memory&#39;.  For example, in ((.)*) we save</span>
<span class="comment">                 registers 1 and 2 as a result of the *, but when we pop</span>
<span class="comment">                 back to the second ), we are at the stop_memory 1.</span>
<span class="comment">                 Thus, nothing is active.  */</span>
          <span class="keywordflow">if</span> (r == 0)
                {
                  lowest_active_reg = <a class="code" href="regex_8c.html#a508c8adae6628ee43b8498249272efb9">NO_LOWEST_ACTIVE_REG</a>;
                  highest_active_reg = <a class="code" href="regex_8c.html#ab79c167c4cd771eeb9f88cf07c8b66c2">NO_HIGHEST_ACTIVE_REG</a>;
                }
              <span class="keywordflow">else</span>
                highest_active_reg = r;
            }

          <span class="comment">/* If just failed to match something this time around with a</span>
<span class="comment">             group that&#39;s operated on by a repetition operator, try to</span>
<span class="comment">             force exit from the ``loop&#39;&#39;, and restore the register</span>
<span class="comment">             information for this group that we had before trying this</span>
<span class="comment">             last match.  */</span>
          <span class="keywordflow">if</span> ((!<a class="code" href="regex_8c.html#a37aeb4969c6ded152f5be7582330e6e5">MATCHED_SOMETHING</a> (reg_info[*p])
               || just_past_start_mem == p - 1)
          &amp;&amp; (p + 2) &lt; pend)
            {
              <span class="keywordtype">boolean</span> is_a_jump_n = <span class="keyword">false</span>;

              p1 = p + 2;
              mcnt = 0;
              <span class="keywordflow">switch</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1++)
                {
                  <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>:
            is_a_jump_n = <span class="keyword">true</span>;
                  <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>:
          <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>:
          <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>:
          <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>:
                    <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
            <span class="keywordflow">if</span> (is_a_jump_n)
              p1 += 2;
                    <span class="keywordflow">break</span>;

                  <span class="keywordflow">default</span>:
                    <span class="comment">/* do nothing */</span> ;
                }
          p1 += mcnt;

              <span class="comment">/* If the next operation is a jump backwards in the pattern</span>
<span class="comment">             to an on_failure_jump right before the start_memory</span>
<span class="comment">                 corresponding to this stop_memory, exit from the loop</span>
<span class="comment">                 by forcing a failure after pushing on the stack the</span>
<span class="comment">                 on_failure_jump&#39;s jump in the pattern, and d.  */</span>
              <span class="keywordflow">if</span> (mcnt &lt; 0 &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>
                  &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a> &amp;&amp; p1[4] == *p)
        {
                  <span class="comment">/* If this group ever matched anything, then restore</span>
<span class="comment">                     what its registers were before trying this last</span>
<span class="comment">                     failed match, e.g., with `(a*)*b&#39; against `ab&#39; for</span>
<span class="comment">                     regstart[1], and, e.g., with `((a*)*(b*)*)*&#39;</span>
<span class="comment">                     against `aba&#39; for regend[3].</span>
<span class="comment"></span>
<span class="comment">                     Also restore the registers for inner groups for,</span>
<span class="comment">                     e.g., `((a*)(b*))*&#39; against `aba&#39; (register 3 would</span>
<span class="comment">                     otherwise get trashed).  */</span>

                  <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#ad4e9639db811e6b09f31ff92466b404e">EVER_MATCHED_SOMETHING</a> (reg_info[*p]))
            {
              <span class="keywordtype">unsigned</span> r;

                      <a class="code" href="regex_8c.html#ad4e9639db811e6b09f31ff92466b404e">EVER_MATCHED_SOMETHING</a> (reg_info[*p]) = 0;

              <span class="comment">/* Restore this and inner groups&#39; (if any) registers.  */</span>
                      <span class="keywordflow">for</span> (r = *p; r &lt; (unsigned) *p + (<span class="keywordtype">unsigned</span>) *(p + 1);
               r++)
                        {
                          regstart[r] = old_regstart[r];

                          <span class="comment">/* xx why this test?  */</span>
                          <span class="keywordflow">if</span> (old_regend[r] &gt;= regstart[r])
                            regend[r] = old_regend[r];
                        }
                    }
          p1++;
                  <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
                  <a class="code" href="regex_8c.html#a74904744b0c1f8fe8cb2bf1584da2b3b">PUSH_FAILURE_POINT</a> (p1 + mcnt, d, -2);

                  <span class="keywordflow">goto</span> fail;
                }
            }

          <span class="comment">/* Move past the register number and the inner group count.  */</span>
          p += 2;
          <span class="keywordflow">break</span>;


    <span class="comment">/* &lt;digit&gt; has been turned into a `duplicate&#39; command which is</span>
<span class="comment">           followed by the numeric value of &lt;digit&gt; as the register number.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de">duplicate</a>:
      {
        <span class="keyword">register</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *d2, *dend2;
        <span class="keywordtype">int</span> regno = *p++;   <span class="comment">/* Get which register to match against.  */</span>
        <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING duplicate %d.\n&quot;</span>, regno);

        <span class="comment">/* Can&#39;t back reference a group which we&#39;ve never matched.  */</span>
            <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a> (regstart[regno]) || <a class="code" href="regex_8c.html#afefb76392029f59835538d01a0c13242">REG_UNSET</a> (regend[regno]))
              <span class="keywordflow">goto</span> fail;

            <span class="comment">/* Where in input to try to start matching.  */</span>
            d2 = regstart[regno];

            <span class="comment">/* Where to stop matching; if both the place to start and</span>
<span class="comment">               the place to stop matching are in the same string, then</span>
<span class="comment">               set to the place to stop, otherwise, for now have to use</span>
<span class="comment">               the end of the first string.  */</span>

            dend2 = ((<a class="code" href="regex_8c.html#a490c47f87b80eb6afdb77510567659e4">FIRST_STRING_P</a> (regstart[regno])
              == <a class="code" href="regex_8c.html#a490c47f87b80eb6afdb77510567659e4">FIRST_STRING_P</a> (regend[regno]))
             ? regend[regno] : end_match_1);
        <span class="keywordflow">for</span> (;;)
          {
        <span class="comment">/* If necessary, advance to next segment in register</span>
<span class="comment">                   contents.  */</span>
        <span class="keywordflow">while</span> (d2 == dend2)
          {
            <span class="keywordflow">if</span> (dend2 == end_match_2) <span class="keywordflow">break</span>;
            <span class="keywordflow">if</span> (dend2 == regend[regno]) <span class="keywordflow">break</span>;

                    <span class="comment">/* End of string1 =&gt; advance to string2. */</span>
                    d2 = string2;
                    dend2 = regend[regno];
          }
        <span class="comment">/* At end of register contents =&gt; success */</span>
        <span class="keywordflow">if</span> (d2 == dend2) <span class="keywordflow">break</span>;

        <span class="comment">/* If necessary, advance to next segment in data.  */</span>
        <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();

        <span class="comment">/* How many characters left in this segment to match.  */</span>
        mcnt = dend - d;

        <span class="comment">/* Want how many consecutive characters we can match in</span>
<span class="comment">                   one shot, so, if necessary, adjust the count.  */</span>
                <span class="keywordflow">if</span> (mcnt &gt; dend2 - d2)
          mcnt = dend2 - d2;

        <span class="comment">/* Compare that many; failure if mismatch, else move</span>
<span class="comment">                   past them.  */</span>
        <span class="keywordflow">if</span> (translate
                    ? <a class="code" href="regex_8c.html#a831fca3c806cff281a70c8757c40b134">bcmp_translate</a> (d, d2, mcnt, translate)
                    : <a class="code" href="regex_8c.html#a98d0dff0c7366f08562d8e8583df9bb9">memcmp</a> (d, d2, mcnt))
          <span class="keywordflow">goto</span> fail;
        d += mcnt, d2 += mcnt;

        <span class="comment">/* Do this because we&#39;ve match some characters.  */</span>
        <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
          }
      }
      <span class="keywordflow">break</span>;


        <span class="comment">/* begline matches the empty string at the beginning of the string</span>
<span class="comment">           (unless `not_bol&#39; is set in `bufp&#39;), and, if</span>
<span class="comment">           `newline_anchor&#39; is set, after newlines.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING begline.\n&quot;</span>);

          <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a> (d))
            {
              <span class="keywordflow">if</span> (!bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a4a5d480a0891afbab92cf486a04e4a68">not_bol</a>) <span class="keywordflow">break</span>;
            }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (d[-1] == <span class="charliteral">&#39;\n&#39;</span> &amp;&amp; bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a>)
            {
              <span class="keywordflow">break</span>;
            }
          <span class="comment">/* In all other cases, we fail.  */</span>
          <span class="keywordflow">goto</span> fail;


        <span class="comment">/* endline is the dual of begline.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING endline.\n&quot;</span>);

          <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a828f1cb8f3855b8656267c902effad75">AT_STRINGS_END</a> (d))
            {
              <span class="keywordflow">if</span> (!bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a875954f4e64b585471f67b334d33799c">not_eol</a>) <span class="keywordflow">break</span>;
            }

          <span class="comment">/* We have to ``prefetch&#39;&#39; the next character.  */</span>
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((d == end1 ? *string2 : *d) == <span class="charliteral">&#39;\n&#39;</span>
                   &amp;&amp; bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a>)
            {
              <span class="keywordflow">break</span>;
            }
          <span class="keywordflow">goto</span> fail;


    <span class="comment">/* Match at the very beginning of the data.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING begbuf.\n&quot;</span>);
          <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a> (d))
            <span class="keywordflow">break</span>;
          <span class="keywordflow">goto</span> fail;


    <span class="comment">/* Match at the very end of the data.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775">endbuf</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING endbuf.\n&quot;</span>);
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a828f1cb8f3855b8656267c902effad75">AT_STRINGS_END</a> (d))
        <span class="keywordflow">break</span>;
          <span class="keywordflow">goto</span> fail;


        <span class="comment">/* on_failure_keep_string_jump is used to optimize `.*\n&#39;.  It</span>
<span class="comment">           pushes NULL as the value for the string on the stack.  Then</span>
<span class="comment">           `pop_failure_point&#39; will keep the current value for the</span>
<span class="comment">           string, instead of restoring it.  To see why, consider</span>
<span class="comment">           matching `foo\nbar&#39; against `.*\n&#39;.  The .* matches the foo;</span>
<span class="comment">           then the . fails against the \n.  But the next thing we want</span>
<span class="comment">           to do is match the \n against the \n; if we restored the</span>
<span class="comment">           string value, we would be back at the foo.</span>
<span class="comment"></span>
<span class="comment">           Because this is used only in specific cases, we don&#39;t need to</span>
<span class="comment">           check all the things that `on_failure_jump&#39; does, to make</span>
<span class="comment">           sure the right things get saved on the stack.  Hence we don&#39;t</span>
<span class="comment">           share its code.  The only reason to push anything on the</span>
<span class="comment">           stack at all is that otherwise we would have to change</span>
<span class="comment">           `anychar&#39;s code to do something besides goto fail in this</span>
<span class="comment">           case; that seems worse than this.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b">on_failure_keep_string_jump</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING on_failure_keep_string_jump&quot;</span>);

          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p);
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot; %d (to %p):\n&quot;</span>, mcnt, p + mcnt);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot; %d (to 0x%x):\n&quot;</span>, mcnt, p + mcnt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
          <a class="code" href="regex_8c.html#a74904744b0c1f8fe8cb2bf1584da2b3b">PUSH_FAILURE_POINT</a> (p + mcnt, <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, -2);
          <span class="keywordflow">break</span>;


    <span class="comment">/* Uses of on_failure_jump:</span>
<span class="comment"></span>
<span class="comment">           Each alternative starts with an on_failure_jump that points</span>
<span class="comment">           to the beginning of the next alternative.  Each alternative</span>
<span class="comment">           except the last ends with a jump that in effect jumps past</span>
<span class="comment">           the rest of the alternatives.  (They really jump to the</span>
<span class="comment">           ending jump of the following alternative, because tensioning</span>
<span class="comment">           these jumps is a hassle.)</span>
<span class="comment"></span>
<span class="comment">           Repeats start with an on_failure_jump that points past both</span>
<span class="comment">           the repetition text and either the following jump or</span>
<span class="comment">           pop_failure_jump back to this on_failure_jump.  */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>:
        on_failure:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING on_failure_jump&quot;</span>);

          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p);
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot; %d (to %p)&quot;</span>, mcnt, p + mcnt);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot; %d (to 0x%x)&quot;</span>, mcnt, p + mcnt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
          <span class="comment">/* If this on_failure_jump comes right before a group (i.e.,</span>
<span class="comment">             the original * applied to a group), save the information</span>
<span class="comment">             for that group and all inner ones, so that if we fail back</span>
<span class="comment">             to this point, the group&#39;s information will be correct.</span>
<span class="comment">             For example, in \(a*\)*\1, we need the preceding group,</span>
<span class="comment">             and in \(zz\(a*\)b*\)\2, we need the inner group.  */</span>

          <span class="comment">/* We can&#39;t use `p&#39; to check ahead because we push</span>
<span class="comment">             a failure point to `p + mcnt&#39; after we do this.  */</span>
          p1 = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

          <span class="comment">/* We need to skip no_op&#39;s before we look for the</span>
<span class="comment">             start_memory in case this on_failure_jump is happening as</span>
<span class="comment">             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1</span>
<span class="comment">             against aba.  */</span>
          <span class="keywordflow">while</span> (p1 &lt; pend &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a>)
            p1++;

          <span class="keywordflow">if</span> (p1 &lt; pend &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>)
            {
              <span class="comment">/* We have a new highest active register now.  This will</span>
<span class="comment">                 get reset at the start_memory we are about to get to,</span>
<span class="comment">                 but we will have saved all the registers relevant to</span>
<span class="comment">                 this repetition op, as described above.  */</span>
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
              <span class="keywordflow">if</span> (lowest_active_reg == <a class="code" href="regex_8c.html#a508c8adae6628ee43b8498249272efb9">NO_LOWEST_ACTIVE_REG</a>)
                lowest_active_reg = *(p1 + 1);
            }

          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;:\n&quot;</span>);
          <a class="code" href="regex_8c.html#a74904744b0c1f8fe8cb2bf1584da2b3b">PUSH_FAILURE_POINT</a> (p + mcnt, d, -2);
          <span class="keywordflow">break</span>;


        <span class="comment">/* A smart repeat ends with `maybe_pop_jump&#39;.</span>
<span class="comment">       We change it to either `pop_failure_jump&#39; or `jump&#39;.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>:
          <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p);
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING maybe_pop_jump %d.\n&quot;</span>, mcnt);
          {
        <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p2 = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

            <span class="comment">/* Compare the beginning of the repeat with what in the</span>
<span class="comment">               pattern follows its end. If we can establish that there</span>
<span class="comment">               is nothing that they would both match, i.e., that we</span>
<span class="comment">               would have to backtrack because of (as in, e.g., `a*a&#39;)</span>
<span class="comment">               then we can change to pop_failure_jump, because we&#39;ll</span>
<span class="comment">               never have to backtrack.</span>
<span class="comment"></span>
<span class="comment">               This is not true in the case of alternatives: in</span>
<span class="comment">               `(a|ab)*&#39; we do need to backtrack to the `ab&#39; alternative</span>
<span class="comment">               (e.g., if the string was `ab&#39;).  But instead of trying to</span>
<span class="comment">               detect that here, the alternative has put on a dummy</span>
<span class="comment">               failure point which is what we will end up popping.  */</span>

        <span class="comment">/* Skip over open/close-group commands.</span>
<span class="comment">           If what follows this loop is a ...+ construct,</span>
<span class="comment">           look at what begins its body, since we will have to</span>
<span class="comment">           match at least one of that.  */</span>
        <span class="keywordflow">while</span> (1)
          {
        <span class="keywordflow">if</span> (p2 + 2 &lt; pend
            &amp;&amp; ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p2 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>
            || (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p2 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>))
          p2 += 3;
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p2 + 6 &lt; pend
             &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p2 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>)
          p2 += 6;
        <span class="keywordflow">else</span>
          <span class="keywordflow">break</span>;
          }

        p1 = p + mcnt;
        <span class="comment">/* p1[0] ... p1[2] are the `on_failure_jump&#39; corresponding</span>
<span class="comment">           to the `maybe_finalize_jump&#39; of this case.  Examine what</span>
<span class="comment">           follows.  */</span>

            <span class="comment">/* If we&#39;re at the end of the pattern, we can change.  */</span>
            <span class="keywordflow">if</span> (p2 == pend)
          {
        <span class="comment">/* Consider what happens when matching &quot;:\(.*\)&quot;</span>
<span class="comment">           against &quot;:/&quot;.  I don&#39;t really understand this code</span>
<span class="comment">           yet.  */</span>
            p[-3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>;
                <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a>
                  (<span class="stringliteral">&quot;  End of pattern: change to `pop_failure_jump&#39;.\n&quot;</span>);
              }

            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p2 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>
             || (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a> &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p2 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>))
          {
        <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c
                  = *p2 == (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a> ? <span class="charliteral">&#39;\n&#39;</span> : p2[2];

                <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a> &amp;&amp; p1[5] != c)
                  {
            p[-3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>;
                    <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  %c != %c =&gt; pop_failure_jump.\n&quot;</span>,
                                  c, p1[5]);
                  }

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>
             || (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>)
          {
            <span class="keywordtype">int</span> not = (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>;

            <span class="keywordflow">if</span> (c &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) (p1[4] * <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>)
            &amp;&amp; p1[5 + c / BYTEWIDTH] &amp; (1 &lt;&lt; (c % BYTEWIDTH)))
              not = !not;

                    <span class="comment">/* `not&#39; is equal to 1 if c would match, which means</span>
<span class="comment">                        that we can&#39;t change to pop_failure_jump.  */</span>
            <span class="keywordflow">if</span> (!not)
                      {
                p[-3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>;
                        <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;  No match =&gt; pop_failure_jump.\n&quot;</span>);
                      }
          }
          }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p2 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>)
          {
<span class="preprocessor">#ifdef DEBUG</span>
<span class="preprocessor"></span>        <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c
                  = *p2 == (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a> ? <span class="charliteral">&#39;\n&#39;</span> : p2[2];
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>                <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>
            &amp;&amp; ! ((int) p2[1] * BYTEWIDTH &gt; (<span class="keywordtype">int</span>) p1[5]
              &amp;&amp; (p2[2 + p1[5] / <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>]
                  &amp; (1 &lt;&lt; (p1[5] % <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>)))))
#<span class="keywordflow">else</span>
                <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>
            &amp;&amp; ! ((int) p2[1] * BYTEWIDTH &gt; (<span class="keywordtype">int</span>) p1[4]
              &amp;&amp; (p2[2 + p1[4] / <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>]
                  &amp; (1 &lt;&lt; (p1[4] % <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>)))))
#endif
                  {
            p[-3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>;
                    <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  %c != %c =&gt; pop_failure_jump.\n&quot;</span>,
                                  c, p1[5]);
                  }

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>)
          {
            <span class="keywordtype">int</span> idx;
            <span class="comment">/* We win if the charset_not inside the loop</span>
<span class="comment">               lists every character listed in the charset after.  */</span>
            <span class="keywordflow">for</span> (idx = 0; idx &lt; (int) p2[1]; idx++)
              <span class="keywordflow">if</span> (! (p2[2 + idx] == 0
                 || (idx &lt; (<span class="keywordtype">int</span>) p1[4]
                 &amp;&amp; ((p2[2 + idx] &amp; ~ p1[5 + idx]) == 0))))
            <span class="keywordflow">break</span>;

            <span class="keywordflow">if</span> (idx == p2[1])
                      {
                p[-3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>;
                        <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;  No match =&gt; pop_failure_jump.\n&quot;</span>);
                      }
          }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p1[3] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>)
          {
            <span class="keywordtype">int</span> idx;
            <span class="comment">/* We win if the charset inside the loop</span>
<span class="comment">               has no overlap with the one after the loop.  */</span>
            <span class="keywordflow">for</span> (idx = 0;
             idx &lt; (int) p2[1] &amp;&amp; idx &lt; (<span class="keywordtype">int</span>) p1[4];
             idx++)
              if ((p2[2 + idx] &amp; p1[5 + idx]) != 0)
            break;

            if (idx == p2[1] || idx == p1[4])
                      {
                p[-3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>;
                        <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;  No match =&gt; pop_failure_jump.\n&quot;</span>);
                      }
          }
          }
      }
      p -= 2;       <span class="comment">/* Point at relative address again.  */</span>
      <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) p[-1] != <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>)
        {
          p[-1] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>;
              <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;  Match =&gt; jump.\n&quot;</span>);
          <span class="keywordflow">goto</span> unconditional_jump;
        }
        <span class="comment">/* Note fall through.  */</span>


    <span class="comment">/* The end of a simple repeat has a pop_failure_jump back to</span>
<span class="comment">           its matching on_failure_jump, where the latter will push a</span>
<span class="comment">           failure point.  The pop_failure_jump takes off failure</span>
<span class="comment">           points put on by this pop_failure_jump&#39;s matching</span>
<span class="comment">           on_failure_jump; we got through the pattern to here from the</span>
<span class="comment">           matching on_failure_jump, so didn&#39;t fail.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>:
          {
            <span class="comment">/* We need to pass separate storage for the lowest and</span>
<span class="comment">               highest registers, even though we don&#39;t care about the</span>
<span class="comment">               actual values.  Otherwise, we will restore only one</span>
<span class="comment">               register from the stack, since lowest will == highest in</span>
<span class="comment">               `pop_failure_point&#39;.  */</span>
            <a class="code" href="regex-gnu_8h.html#ab64c4b3b9990d5c9e7e30219aecec37a">active_reg_t</a> dummy_low_reg, dummy_high_reg;
            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pdummy;
            <span class="keyword">const</span> <span class="keywordtype">char</span> *sdummy;

            <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING pop_failure_jump.\n&quot;</span>);
            <a class="code" href="regex_8c.html#a51d78204b5e3cc240058c986103c8b8e">POP_FAILURE_POINT</a> (sdummy, pdummy,
                               dummy_low_reg, dummy_high_reg,
                               reg_dummy, reg_dummy, reg_info_dummy);
          }
      <span class="comment">/* Note fall through.  */</span>

    unconditional_jump:
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;\n%p: &quot;</span>, p);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>      <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;\n0x%x: &quot;</span>, p);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>          <span class="comment">/* Note fall through.  */</span>

        <span class="comment">/* Unconditionally jump (without popping any failure points).  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>:
      <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p);    <span class="comment">/* Get the amount to jump.  */</span>
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING jump %d &quot;</span>, mcnt);
      p += mcnt;                <span class="comment">/* Do the jump.  */</span>
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;(to %p).\n&quot;</span>, p);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;(to 0x%x).\n&quot;</span>, p);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>      <span class="keywordflow">break</span>;


        <span class="comment">/* We need this opcode so we can detect where alternatives end</span>
<span class="comment">           in `group_match_null_string_p&#39; et al.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING jump_past_alt.\n&quot;</span>);
          <span class="keywordflow">goto</span> unconditional_jump;


        <span class="comment">/* Normally, the on_failure_jump pushes a failure point, which</span>
<span class="comment">           then gets popped at pop_failure_jump.  We will end up at</span>
<span class="comment">           pop_failure_jump, also, and with a pattern of, say, `a+&#39;, we</span>
<span class="comment">           are skipping over the on_failure_jump, so we have to push</span>
<span class="comment">           something meaningless for pop_failure_jump to pop.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING dummy_failure_jump.\n&quot;</span>);
          <span class="comment">/* It doesn&#39;t matter what we push for the string here.  What</span>
<span class="comment">             the code at `fail&#39; tests is the value for the pattern.  */</span>
          <a class="code" href="regex_8c.html#a74904744b0c1f8fe8cb2bf1584da2b3b">PUSH_FAILURE_POINT</a> (<a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, -2);
          <span class="keywordflow">goto</span> unconditional_jump;


        <span class="comment">/* At the end of an alternative, we need to push a dummy failure</span>
<span class="comment">           point in case we are followed by a `pop_failure_jump&#39;, because</span>
<span class="comment">           we don&#39;t want the failure point for the alternative to be</span>
<span class="comment">           popped.  For example, matching `(a|ab)*&#39; against `aab&#39;</span>
<span class="comment">           requires that we match the `ab&#39; alternative.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f">push_dummy_failure</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING push_dummy_failure.\n&quot;</span>);
          <span class="comment">/* See comments just above at `dummy_failure_jump&#39; about the</span>
<span class="comment">             two zeroes.  */</span>
          <a class="code" href="regex_8c.html#a74904744b0c1f8fe8cb2bf1584da2b3b">PUSH_FAILURE_POINT</a> (<a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, -2);
          <span class="keywordflow">break</span>;

        <span class="comment">/* Have to succeed matching what follows at least n times.</span>
<span class="comment">           After that, handle like `on_failure_jump&#39;.  */</span>
        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>:
          <a class="code" href="regex_8c.html#a9afddc5990335682b1958801af7e4bf3">EXTRACT_NUMBER</a> (mcnt, p + 2);
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING succeed_n %d.\n&quot;</span>, mcnt);

          <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (mcnt &gt;= 0);
          <span class="comment">/* Originally, this is how many times we HAVE to succeed.  */</span>
          <span class="keywordflow">if</span> (mcnt &gt; 0)
            {
               mcnt--;
           p += 2;
               <a class="code" href="regex_8c.html#aec2d0e7545b2756d65a556d3ac7cdf89">STORE_NUMBER_AND_INCR</a> (p, mcnt);
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>               <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  Setting %p to %d.\n&quot;</span>, p - 2, mcnt);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>               <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  Setting 0x%x to %d.\n&quot;</span>, p - 2, mcnt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mcnt == 0)
            {
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>              <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;  Setting two bytes from %p to no_op.\n&quot;</span>, p+2);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>              <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;  Setting two bytes from 0x%x to no_op.\n&quot;</span>, p+2);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>          p[2] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a>;
              p[3] = (<span class="keywordtype">unsigned</span> char) <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a292eb17c5d97bf50ef0c4f733e56c836">no_op</a>;
              <span class="keywordflow">goto</span> on_failure;
            }
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>:
          <a class="code" href="regex_8c.html#a9afddc5990335682b1958801af7e4bf3">EXTRACT_NUMBER</a> (mcnt, p + 2);
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING jump_n %d.\n&quot;</span>, mcnt);

          <span class="comment">/* Originally, this is how many times we CAN jump.  */</span>
          <span class="keywordflow">if</span> (mcnt)
            {
               mcnt--;
               <a class="code" href="regex_8c.html#a6878991bbaf83ac3debe1d74f4a450e1">STORE_NUMBER</a> (p + 2, mcnt);
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>               <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  Setting %p to %d.\n&quot;</span>, p + 2, mcnt);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>               <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  Setting 0x%x to %d.\n&quot;</span>, p + 2, mcnt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>           <span class="keywordflow">goto</span> unconditional_jump;
            }
          <span class="comment">/* If don&#39;t have to jump any more, skip over the rest of command.  */</span>
      <span class="keywordflow">else</span>
        p += 4;
          <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>:
      {
            <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING set_number_at.\n&quot;</span>);

            <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p);
            p1 = p + mcnt;
            <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p);
<span class="preprocessor">#ifdef _LIBC</span>
<span class="preprocessor"></span>            <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  Setting %p to %d.\n&quot;</span>, p1, mcnt);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>            <a class="code" href="regex_8c.html#ae1a07ee1a4b73aa71754bce23d0690aa">DEBUG_PRINT3</a> (<span class="stringliteral">&quot;  Setting 0x%x to %d.\n&quot;</span>, p1, mcnt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <a class="code" href="regex_8c.html#a6878991bbaf83ac3debe1d74f4a450e1">STORE_NUMBER</a> (p1, mcnt);
            <span class="keywordflow">break</span>;
          }

<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>    <span class="comment">/* The DEC Alpha C compiler 3.x generates incorrect code for the</span>
<span class="comment">       test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of</span>
<span class="comment">       AT_WORD_BOUNDARY, so this code is disabled.  Expanding the</span>
<span class="comment">       macro and introducing temporary variables works around the bug.  */</span>

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>:
      <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING wordbound.\n&quot;</span>);
      <span class="keywordflow">if</span> (AT_WORD_BOUNDARY (d))
        <span class="keywordflow">break</span>;
      <span class="keywordflow">goto</span> fail;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>:
      <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING notwordbound.\n&quot;</span>);
      <span class="keywordflow">if</span> (AT_WORD_BOUNDARY (d))
        <span class="keywordflow">goto</span> fail;
      <span class="keywordflow">break</span>;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>:
    {
      <span class="keywordtype">boolean</span> prevchar, thischar;

      <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING wordbound.\n&quot;</span>);
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a> (d) || <a class="code" href="regex_8c.html#a828f1cb8f3855b8656267c902effad75">AT_STRINGS_END</a> (d))
        <span class="keywordflow">break</span>;

      prevchar = <a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d - 1);
      thischar = <a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d);
      <span class="keywordflow">if</span> (prevchar != thischar)
        <span class="keywordflow">break</span>;
      <span class="keywordflow">goto</span> fail;
    }

      <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>:
    {
      <span class="keywordtype">boolean</span> prevchar, thischar;

      <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING notwordbound.\n&quot;</span>);
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a> (d) || <a class="code" href="regex_8c.html#a828f1cb8f3855b8656267c902effad75">AT_STRINGS_END</a> (d))
        <span class="keywordflow">goto</span> fail;

      prevchar = <a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d - 1);
      thischar = <a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d);
      <span class="keywordflow">if</span> (prevchar != thischar)
        <span class="keywordflow">goto</span> fail;
      <span class="keywordflow">break</span>;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18">wordbeg</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING wordbeg.\n&quot;</span>);
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d) &amp;&amp; (<a class="code" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a> (d) || !<a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d - 1)))
        <span class="keywordflow">break</span>;
          <span class="keywordflow">goto</span> fail;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac">wordend</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING wordend.\n&quot;</span>);
      <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a4ae509096aba99683d03e7731c8e1095">AT_STRINGS_BEG</a> (d) &amp;&amp; <a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d - 1)
              &amp;&amp; (!<a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d) || <a class="code" href="regex_8c.html#a828f1cb8f3855b8656267c902effad75">AT_STRINGS_END</a> (d)))
        <span class="keywordflow">break</span>;
          <span class="keywordflow">goto</span> fail;

<span class="preprocessor">#ifdef emacs</span>
<span class="preprocessor"></span>    <span class="keywordflow">case</span> before_dot:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING before_dot.\n&quot;</span>);
      <span class="keywordflow">if</span> (PTR_CHAR_POS ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) d) &gt;= point)
        <span class="keywordflow">goto</span> fail;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> at_dot:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING at_dot.\n&quot;</span>);
      <span class="keywordflow">if</span> (PTR_CHAR_POS ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) d) != point)
        <span class="keywordflow">goto</span> fail;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> after_dot:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING after_dot.\n&quot;</span>);
          <span class="keywordflow">if</span> (PTR_CHAR_POS ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) d) &lt;= point)
        <span class="keywordflow">goto</span> fail;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> syntaxspec:
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING syntaxspec %d.\n&quot;</span>, mcnt);
      mcnt = *p++;
      <span class="keywordflow">goto</span> matchsyntax;

        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b">wordchar</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING Emacs wordchar.\n&quot;</span>);
      mcnt = (int) <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>;
        matchsyntax:
      <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
      <span class="comment">/* Can&#39;t use *d++ here; SYNTAX may be an unsafe macro.  */</span>
      d++;
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> (d[-1]) != (<span class="keyword">enum</span> syntaxcode) mcnt)
        <span class="keywordflow">goto</span> fail;
          <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> notsyntaxspec:
          <a class="code" href="regex_8c.html#aa56b1ff14ec552b5af8e9af50bc9d5cc">DEBUG_PRINT2</a> (<span class="stringliteral">&quot;EXECUTING notsyntaxspec %d.\n&quot;</span>, mcnt);
      mcnt = *p++;
      <span class="keywordflow">goto</span> matchnotsyntax;

        <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93">notwordchar</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING Emacs notwordchar.\n&quot;</span>);
      mcnt = (int) <a class="code" href="regex_8c.html#a3c4fa96131648fe8cb5bb3055015e73a">Sword</a>;
        matchnotsyntax:
      <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
      <span class="comment">/* Can&#39;t use *d++ here; SYNTAX may be an unsafe macro.  */</span>
      d++;
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#aa3ac3cf24b0571b34350ae5cf10f354e">SYNTAX</a> (d[-1]) == (<span class="keyword">enum</span> syntaxcode) mcnt)
        <span class="keywordflow">goto</span> fail;
      <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
          <span class="keywordflow">break</span>;

<span class="preprocessor">#else </span><span class="comment">/* not emacs */</span>
    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b">wordchar</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING non-Emacs wordchar.\n&quot;</span>);
      <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
          <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d))
            <span class="keywordflow">goto</span> fail;
      <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
          d++;
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93">notwordchar</a>:
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;EXECUTING non-Emacs notwordchar.\n&quot;</span>);
      <a class="code" href="regex_8c.html#a03e91c701217af9b9faab62cb2a65d7d">PREFETCH</a> ();
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a9cb82d6af5bb56ce088c91cef5127ce6">WORDCHAR_P</a> (d))
            <span class="keywordflow">goto</span> fail;
          <a class="code" href="regex_8c.html#aa286396ee78a5823c6bedd72e303e4c9">SET_REGS_MATCHED</a> ();
          d++;
      <span class="keywordflow">break</span>;
<span class="preprocessor">#endif </span><span class="comment">/* not emacs */</span>

        <span class="keywordflow">default</span>:
          abort ();
    }
      <span class="keywordflow">continue</span>;  <span class="comment">/* Successfully executed one pattern command; keep going.  */</span>


    <span class="comment">/* We goto here if a matching operation fails. */</span>
    fail:
      <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a222a4648230cba6a1801e51b4e2ced77">FAIL_STACK_EMPTY</a> ())
    { <span class="comment">/* A restart point is known.  Restore to that state.  */</span>
          <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;\nFAIL:\n&quot;</span>);
          <a class="code" href="regex_8c.html#a51d78204b5e3cc240058c986103c8b8e">POP_FAILURE_POINT</a> (d, p,
                             lowest_active_reg, highest_active_reg,
                             regstart, regend, reg_info);

          <span class="comment">/* If this failure point is a dummy, try the next one.  */</span>
          <span class="keywordflow">if</span> (!p)
        <span class="keywordflow">goto</span> fail;

          <span class="comment">/* If we failed to the end of the pattern, don&#39;t examine *p.  */</span>
      <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (p &lt;= pend);
          <span class="keywordflow">if</span> (p &lt; pend)
            {
              <span class="keywordtype">boolean</span> is_a_jump_n = <span class="keyword">false</span>;

              <span class="comment">/* If failed to a backwards jump that&#39;s part of a repetition</span>
<span class="comment">                 loop, need to pop this failure point and use the next one.  */</span>
              <span class="keywordflow">switch</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p)
                {
                <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>:
                  is_a_jump_n = <span class="keyword">true</span>;
                <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>:
                <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a24cdcea4f39ca8613374deb4bfe5b2cb">pop_failure_jump</a>:
                <span class="keywordflow">case</span> <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>:
                  p1 = p + 1;
                  <a class="code" href="regex_8c.html#abf958c753956f073a33bd336660e9038">EXTRACT_NUMBER_AND_INCR</a> (mcnt, p1);
                  p1 += mcnt;

                  <span class="keywordflow">if</span> ((is_a_jump_n &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>)
                      || (!is_a_jump_n
                          &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) *p1 == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>))
                    <span class="keywordflow">goto</span> fail;
                  <span class="keywordflow">break</span>;
                <span class="keywordflow">default</span>:
                  <span class="comment">/* do nothing */</span> ;
                }
            }

          <span class="keywordflow">if</span> (d &gt;= string1 &amp;&amp; d &lt;= end1)
        dend = end_match_1;
        }
      <span class="keywordflow">else</span>
        <span class="keywordflow">break</span>;   <span class="comment">/* Matching at this starting point really fails.  */</span>
    } <span class="comment">/* for (;;) */</span>

  <span class="keywordflow">if</span> (best_regs_set)
    <span class="keywordflow">goto</span> restore_best_regs;
</pre></div>
</div>
</div>
<a class="anchor" id="afe0743116f59f62a4d00f50a9e9a4932"></a><!-- doxytag: member="regex.c::re_search" ref="afe0743116f59f62a4d00f50a9e9a4932" args="(struct re_pattern_buffer *bufp, const char *string, int size, int startpos, int range, struct re_registers *regs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int re_search </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__registers.html">re_registers</a> *&#160;</td>
          <td class="paramname"><em>regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03527">3527</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a22058f53f03b835778e1117d7abf0bd7"></a><!-- doxytag: member="regex.c::re_search_2" ref="a22058f53f03b835778e1117d7abf0bd7" args="(struct re_pattern_buffer *bufp, const char *string1, int size1, const char *string2, int size2, int startpos, int range, struct re_registers *regs, int stop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int re_search_2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__registers.html">re_registers</a> *&#160;</td>
          <td class="paramname"><em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03563">3563</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> <a class="code" href="prefix_8h.html#a43e03366be2dd9176e91229d76541ce9">val</a>;
  <span class="keyword">register</span> <span class="keywordtype">char</span> *fastmap = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a>;
  <span class="keyword">register</span> <a class="code" href="regex-gnu_8h.html#a96c9fb9c7074cb21740b63092b0637a4">RE_TRANSLATE_TYPE</a> translate = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a>;
  <span class="keywordtype">int</span> total_size = size1 + size2;
  <span class="keywordtype">int</span> endpos = startpos + range;

  <span class="comment">/* Check for out-of-range STARTPOS.  */</span>
  <span class="keywordflow">if</span> (startpos &lt; 0 || startpos &gt; total_size)
    <span class="keywordflow">return</span> -1;

  <span class="comment">/* Fix up RANGE if it might eventually take us outside</span>
<span class="comment">     the virtual concatenation of STRING1 and STRING2.</span>
<span class="comment">     Make sure we won&#39;t move STARTPOS below 0 or above TOTAL_SIZE.  */</span>
  <span class="keywordflow">if</span> (endpos &lt; 0)
    range = 0 - startpos;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (endpos &gt; total_size)
    range = total_size - startpos;

  <span class="comment">/* If the search isn&#39;t to be a backwards one, don&#39;t waste time in a</span>
<span class="comment">     search for a pattern that must be anchored.  */</span>
  <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a> &gt; 0 &amp;&amp; range &gt; 0
      &amp;&amp; ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>[0] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>
      <span class="comment">/* `begline&#39; is like `begbuf&#39; if it cannot match at newlines.  */</span>
      || ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>[0] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>
          &amp;&amp; !bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a>)))
    {
      <span class="keywordflow">if</span> (startpos &gt; 0)
    <span class="keywordflow">return</span> -1;
      <span class="keywordflow">else</span>
    range = 1;
    }

<span class="preprocessor">#ifdef emacs</span>
<span class="preprocessor"></span>  <span class="comment">/* In a forward search for something that starts with \=.</span>
<span class="comment">     don&#39;t keep searching past point.  */</span>
  <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a> &gt; 0 &amp;&amp; (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>[0] == at_dot &amp;&amp; range &gt; 0)
    {
      range = PT - startpos;
      <span class="keywordflow">if</span> (range &lt;= 0)
    <span class="keywordflow">return</span> -1;
    }
<span class="preprocessor">#endif </span><span class="comment">/* emacs */</span>

  <span class="comment">/* Update the fastmap now if not correct already.  */</span>
  <span class="keywordflow">if</span> (fastmap &amp;&amp; !bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a837b026312b860e5485da6240b10d8f7">fastmap_accurate</a>)
    <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a39979f3b79c423214dc96b34996424a8">re_compile_fastmap</a> (bufp) == -2)
      <span class="keywordflow">return</span> -2;

  <span class="comment">/* Loop through the string, looking for a place to start matching.  */</span>
  <span class="keywordflow">for</span> (;;)
    {
      <span class="comment">/* If a fastmap is supplied, skip quickly over characters that</span>
<span class="comment">         cannot be the start of a match.  If the pattern can match the</span>
<span class="comment">         null string, however, we don&#39;t need to skip characters; we want</span>
<span class="comment">         the first null string.  */</span>
      <span class="keywordflow">if</span> (fastmap &amp;&amp; startpos &lt; total_size &amp;&amp; !bufp-&gt;can_be_null)
    {
      <span class="keywordflow">if</span> (range &gt; 0)    <span class="comment">/* Searching forwards.  */</span>
        {
          <span class="keyword">register</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *d;
          <span class="keyword">register</span> <span class="keywordtype">int</span> lim = 0;
          <span class="keywordtype">int</span> irange = range;

              <span class="keywordflow">if</span> (startpos &lt; size1 &amp;&amp; startpos + range &gt;= size1)
                lim = range - (size1 - startpos);

          d = (startpos &gt;= size1 ? string2 - size1 : string1) + startpos;

              <span class="comment">/* Written out as an if-else to avoid testing `translate&#39;</span>
<span class="comment">                 inside the loop.  */</span>
          <span class="keywordflow">if</span> (translate)
                <span class="keywordflow">while</span> (range &gt; lim
                       &amp;&amp; !fastmap[(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)
                   translate[(<span class="keywordtype">unsigned</span> char) *d++]])
                  range--;
          <span class="keywordflow">else</span>
                <span class="keywordflow">while</span> (range &gt; lim &amp;&amp; !fastmap[(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *d++])
                  range--;

          startpos += irange - range;
        }
      <span class="keywordflow">else</span>              <span class="comment">/* Searching backwards.  */</span>
        {
          <span class="keyword">register</span> <span class="keywordtype">char</span> c = (size1 == 0 || startpos &gt;= size1
                                 ? string2[startpos - size1]
                                 : string1[startpos]);

          <span class="keywordflow">if</span> (!fastmap[(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (c)])
        <span class="keywordflow">goto</span> advance;
        }
    }

      <span class="comment">/* If can&#39;t match the null string, and that&#39;s all we have left, fail.  */</span>
      <span class="keywordflow">if</span> (range &gt;= 0 &amp;&amp; startpos == total_size &amp;&amp; fastmap
          &amp;&amp; !bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a13807f7bf4b32d786eb9e17a3c4d3124">can_be_null</a>)
    <span class="keywordflow">return</span> -1;

      val = <a class="code" href="regex_8c.html#a3b426565d92028a1cf7113fcf41942c8">re_match_2_internal</a> (bufp, string1, size1, string2, size2,
                 startpos, regs, stop);
<span class="preprocessor">#ifndef REGEX_MALLOC</span>
<span class="preprocessor"></span><span class="preprocessor"># ifdef C_ALLOCA</span>
<span class="preprocessor"></span>      alloca (0);
<span class="preprocessor"># endif</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
      <span class="keywordflow">if</span> (val &gt;= 0)
    <span class="keywordflow">return</span> startpos;

      <span class="keywordflow">if</span> (val == -2)
    <span class="keywordflow">return</span> -2;

    advance:
      <span class="keywordflow">if</span> (!range)
        <span class="keywordflow">break</span>;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (range &gt; 0)
        {
          range--;
          startpos++;
        }
      <span class="keywordflow">else</span>
        {
          range++;
</pre></div>
</div>
</div>
<a class="anchor" id="ad9e4e94e6531ff0387a725491e028a41"></a><!-- doxytag: member="regex.c::re_set_registers" ref="ad9e4e94e6531ff0387a725491e028a41" args="(struct re_pattern_buffer *bufp, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void re_set_registers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__registers.html">re_registers</a> *&#160;</td>
          <td class="paramname"><em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a> *&#160;</td>
          <td class="paramname"><em>starts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a> *&#160;</td>
          <td class="paramname"><em>ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03497">3497</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (num_regs)
    {
      bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a83388321c434be6ac33fe359a3d7b449">regs_allocated</a> = <a class="code" href="regex-gnu_8h.html#a87642301f41c9c37e7f4d10ab5ade987">REGS_REALLOCATE</a>;
      regs-&gt;<a class="code" href="structre__registers.html#aeae8140aadf339f6fe0c49277d6aa7b5">num_regs</a> = num_regs;
      regs-&gt;<a class="code" href="structre__registers.html#a6676ddb6ab07e50191e149b04dbcfe03">start</a> = starts;
      regs-&gt;<a class="code" href="structre__registers.html#a0a9d373f1ab74c9c2063f233476fa5d4">end</a> = ends;
    }
  <span class="keywordflow">else</span>
    {
</pre></div>
</div>
</div>
<a class="anchor" id="ad7a880e03677a7961ddf81cdc73e8fb4"></a><!-- doxytag: member="regex.c::re_set_syntax" ref="ad7a880e03677a7961ddf81cdc73e8fb4" args="(reg_syntax_t syntax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> re_set_syntax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td>
          <td class="paramname"><em>syntax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00997">997</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> ret = <a class="code" href="regex-gnu_8h.html#abdc5e67bbb6a48b740a95aef2bc3f5f2">re_syntax_options</a>;

  <a class="code" href="regex-gnu_8h.html#abdc5e67bbb6a48b740a95aef2bc3f5f2">re_syntax_options</a> = syntax;
<span class="preprocessor">#ifdef DEBUG</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#a8b5102c6c1d783f324012804b26e82cb">RE_DEBUG</a>)
    <a class="code" href="bgp__debug_8c.html#abc1624539747635021518178e4df5a69">debug</a> = 1;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="bgp__debug_8c.html#abc1624539747635021518178e4df5a69">debug</a>) <span class="comment">/* was on but now is not */</span>
    <a class="code" href="bgp__debug_8c.html#abc1624539747635021518178e4df5a69">debug</a> = 0;
<span class="preprocessor">#endif </span><span class="comment">/* DEBUG */</span>
  <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3d4d6185d412b00bc3def2b58b2898cc"></a><!-- doxytag: member="regex.c::realloc" ref="a3d4d6185d412b00bc3def2b58b2898cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* realloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38bbfba560a12468196f72aa88486406"></a><!-- doxytag: member="regex.c::regcomp" ref="a38bbfba560a12468196f72aa88486406" args="(regex_t *preg, const char *pattern, int cflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *&#160;</td>
          <td class="paramname"><em>preg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05662">5662</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> ret;
  <a class="code" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> syntax
    = (cflags &amp; <a class="code" href="regex-gnu_8h.html#a5fc31e6da9b77e09ea62b4544ac4767f">REG_EXTENDED</a>) ?
      <a class="code" href="regex-gnu_8h.html#a18701b3ee3894b158993efa18f3958ec">RE_SYNTAX_POSIX_EXTENDED</a> : <a class="code" href="regex-gnu_8h.html#af0f03965e6d6bdc7576fe863c81bb7af">RE_SYNTAX_POSIX_BASIC</a>;

  <span class="comment">/* regex_compile will allocate the space for the compiled pattern.  */</span>
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> = 0;
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a2947439f970297ce6f4a439867c0b5c7">allocated</a> = 0;
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a> = 0;

  <span class="comment">/* Try to allocate space for the fastmap.  */</span>
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a> = (<span class="keywordtype">char</span> *) <a class="code" href="regex_8c.html#ab7e36af3707843f77cc5b4e831c2fa6d">malloc</a> (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>);

  <span class="keywordflow">if</span> (cflags &amp; <a class="code" href="regex-gnu_8h.html#a0c3e7b1d5bc9c2d278a544fe9b61b67a">REG_ICASE</a>)
    {
      <span class="keywordtype">unsigned</span> <a class="code" href="spgrid_8c.html#a139066bd9e344a8daae82c5ca919fffe">i</a>;

      preg-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a>
    = (<a class="code" href="regex-gnu_8h.html#a96c9fb9c7074cb21740b63092b0637a4">RE_TRANSLATE_TYPE</a>) <a class="code" href="regex_8c.html#ab7e36af3707843f77cc5b4e831c2fa6d">malloc</a> (<a class="code" href="regex_8c.html#adebebe79bb84190296da4c5d67e4e434">CHAR_SET_SIZE</a>
                      * <span class="keyword">sizeof</span> (*(<a class="code" href="regex-gnu_8h.html#a96c9fb9c7074cb21740b63092b0637a4">RE_TRANSLATE_TYPE</a>)0));
      <span class="keywordflow">if</span> (preg-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
        <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaabf0128b7050c81c0fb933ea7265ebe9">REG_ESPACE</a>;

      <span class="comment">/* Map uppercase characters to corresponding lowercase ones.  */</span>
      <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="regex_8c.html#adebebe79bb84190296da4c5d67e4e434">CHAR_SET_SIZE</a>; i++)
        preg-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a>[i] = <a class="code" href="regex_8c.html#a2bfd4177f165a5968d95960d42578ab6">ISUPPER</a> (i) ? <a class="code" href="regex_8c.html#ad4771ad2e5dd6a87c83ecf879b7985de">TOLOWER</a> (i) : i;
    }
  <span class="keywordflow">else</span>
    preg-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a> = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;

  <span class="comment">/* If REG_NEWLINE is set, newlines are treated differently.  */</span>
  <span class="keywordflow">if</span> (cflags &amp; <a class="code" href="regex-gnu_8h.html#ab678ef3b27bf7de2fb82c79cb2cd9d8a">REG_NEWLINE</a>)
    { <span class="comment">/* REG_NEWLINE implies neither . nor [^...] match newline.  */</span>
      syntax &amp;= ~<a class="code" href="regex-gnu_8h.html#a405fe43871f2df60407b3c8272f4624c">RE_DOT_NEWLINE</a>;
      syntax |= <a class="code" href="regex-gnu_8h.html#aad6ec0e3f8f0bb3c53213e3f9ca77d8e">RE_HAT_LISTS_NOT_NEWLINE</a>;
      <span class="comment">/* It also changes the matching behavior.  */</span>
      preg-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a> = 1;
    }
  <span class="keywordflow">else</span>
    preg-&gt;<a class="code" href="structre__pattern__buffer.html#a46ed7a16b4cb87267ac5d219dab3536a">newline_anchor</a> = 0;

  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a83e122c96edb258aa4ef99d7a8b2bfa2">no_sub</a> = !!(cflags &amp; <a class="code" href="regex-gnu_8h.html#abb835c7fe6f1673fc0efeff0064510ab">REG_NOSUB</a>);

  <span class="comment">/* POSIX says a null character in the pattern terminates it, so we</span>
<span class="comment">     can use strlen here in compiling the pattern.  */</span>
  ret = <a class="code" href="regex_8c.html#a6a04e18fe89cacd4b8d04a474def5985">regex_compile</a> (pattern, strlen (pattern), syntax, preg);

  <span class="comment">/* POSIX doesn&#39;t distinguish between an unmatched open-group and an</span>
<span class="comment">     unmatched close-group: both are REG_EPAREN.  */</span>
  <span class="keywordflow">if</span> (ret == <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea5797541a6619c4a5dbe28fe3bb58661b">REG_ERPAREN</a>) ret = <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeabde1462e3a1660e121d79ce2d0cc5664">REG_EPAREN</a>;

  <span class="keywordflow">if</span> (ret == <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeafa64e5a57596c8c859f982512f52cd6b">REG_NOERROR</a> &amp;&amp; preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a>)
    {
      <span class="comment">/* Compute the fastmap now, since regexec cannot modify the pattern</span>
<span class="comment">     buffer.  */</span>
      <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a39979f3b79c423214dc96b34996424a8">re_compile_fastmap</a> (preg) == -2)
    {
      <span class="comment">/* Some error occured while computing the fastmap, just forget</span>
<span class="comment">         about it.  */</span>
      free (preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a>);
      preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a> = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
</pre></div>
</div>
</div>
<a class="anchor" id="a495ccb59d8346de24a54703f66fd517d"></a><!-- doxytag: member="regex.c::regerror" ref="a495ccb59d8346de24a54703f66fd517d" args="(int err, const regex_t *preg, char *errbuf, size_t errbuf_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *&#160;</td>
          <td class="paramname"><em>preg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errbuf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05820">5820</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structmsg.html">msg</a>;
  <span class="keywordtype">size_t</span> msg_size;

  <span class="keywordflow">if</span> (err &lt; 0
      || err &gt;= (<span class="keywordtype">int</span>) (<span class="keyword">sizeof</span> (<a class="code" href="regex_8c.html#aff41b1a2e0447b7f5744746b3abb9530">re_error_msgid_idx</a>)
               / <span class="keyword">sizeof</span> (<a class="code" href="regex_8c.html#aff41b1a2e0447b7f5744746b3abb9530">re_error_msgid_idx</a>[0])))
    <span class="comment">/* Only error codes returned by the rest of the code should be passed</span>
<span class="comment">       to this routine.  If we are given anything else, or if other regex</span>
<span class="comment">       code generates an invalid error code, then the program has a bug.</span>
<span class="comment">       Dump core so we can fix it.  */</span>
    abort ();

  msg = <a class="code" href="regex_8c.html#a84591b979e395c1ecf40f06963f89d8b">gettext</a> (<a class="code" href="regex_8c.html#a4a5e7ab240e155127f898d0a96c68922">re_error_msgid</a> + <a class="code" href="regex_8c.html#aff41b1a2e0447b7f5744746b3abb9530">re_error_msgid_idx</a>[err]);

  msg_size = strlen (msg) + 1; <span class="comment">/* Includes the null.  */</span>

  <span class="keywordflow">if</span> (errbuf_size != 0)
    {
      <span class="keywordflow">if</span> (msg_size &gt; errbuf_size)
        {
<span class="preprocessor">#if defined HAVE_MEMPCPY || defined _LIBC</span>
<span class="preprocessor"></span>      *((<span class="keywordtype">char</span> *) __mempcpy (errbuf, msg, errbuf_size - 1)) = <span class="charliteral">&#39;\0&#39;</span>;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>          <a class="code" href="regex_8c.html#aed653b4838032a2c5ce8960421c8cfd7">memcpy</a> (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }
      <span class="keywordflow">else</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a6a04e18fe89cacd4b8d04a474def5985"></a><!-- doxytag: member="regex.c::regex_compile" ref="a6a04e18fe89cacd4b8d04a474def5985" args="(char *pattern, size_t size, reg_syntax_t syntax, struct re_pattern_buffer *bufp) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> regex_compile </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a>&#160;</td>
          <td class="paramname"><em>syntax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structre__pattern__buffer.html">re_pattern_buffer</a> *&#160;</td>
          <td class="paramname"><em>bufp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01883">1883</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">/* We fetch characters from PATTERN here.  Even though PATTERN is</span>
<span class="comment">     `char *&#39; (i.e., signed), we declare these variables as unsigned, so</span>
<span class="comment">     they can be reliably used as array indices.  */</span>
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c, <a class="code" href="test-checksum_8c.html#a8f9aca421a560153a31ebb326da34216">c1</a>;

  <span class="comment">/* A random temporary spot in PATTERN.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *p1;

  <span class="comment">/* Points to the end of the buffer, where we should append.  */</span>
  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="ripng__nexthop_8h.html#a337ad8a7e52da2d584c2018f2ec2c81e">b</a>;

  <span class="comment">/* Keeps track of unclosed groups.  */</span>
  <a class="code" href="structcompile__stack__type.html">compile_stack_type</a> compile_stack;

  <span class="comment">/* Points to the current (ending) position in the pattern.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a> = pattern;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *pend = pattern + size;

  <span class="comment">/* How to translate the characters in the pattern.  */</span>
  <a class="code" href="regex-gnu_8h.html#a96c9fb9c7074cb21740b63092b0637a4">RE_TRANSLATE_TYPE</a> translate = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a780f81d1ec1ebba869e138b5bc849658">translate</a>;

  <span class="comment">/* Address of the count-byte of the most recently inserted `exactn&#39;</span>
<span class="comment">     command.  This makes it possible to tell if a new exact-match</span>
<span class="comment">     character can be added to that command or if the character requires</span>
<span class="comment">     a new `exactn&#39; command.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pending_exact = 0;

  <span class="comment">/* Address of start of the most recently finished expression.</span>
<span class="comment">     This tells, e.g., postfix * where to find the start of its</span>
<span class="comment">     operand.  Reset at the beginning of groups and alternatives.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *laststart = 0;

  <span class="comment">/* Address of beginning of regexp, or inside of last group.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *begalt;

  <span class="comment">/* Place in the uncompiled pattern (i.e., the {) to</span>
<span class="comment">     which to go back if the interval is invalid.  */</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *beg_interval;

  <span class="comment">/* Address of the place where a forward jump should go to the end of</span>
<span class="comment">     the containing expression.  Each alternative of an `or&#39; -- except the</span>
<span class="comment">     last -- ends with a forward jump of this sort.  */</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *fixup_alt_jump = 0;

  <span class="comment">/* Counts open-groups as they are encountered.  Remembered for the</span>
<span class="comment">     matching close-group on the compile stack, so the same register</span>
<span class="comment">     number is put in the stop_memory as the start_memory.  */</span>
  <a class="code" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a> regnum = 0;

<span class="preprocessor">#ifdef DEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;\nCompiling pattern: &quot;</span>);
  <span class="keywordflow">if</span> (<a class="code" href="bgp__debug_8c.html#abc1624539747635021518178e4df5a69">debug</a>)
    {
      <span class="keywordtype">unsigned</span> debug_count;

      <span class="keywordflow">for</span> (debug_count = 0; debug_count &lt; size; debug_count++)
        putchar (pattern[debug_count]);
      putchar (<span class="charliteral">&#39;\n&#39;</span>);
    }
<span class="preprocessor">#endif </span><span class="comment">/* DEBUG */</span>

  <span class="comment">/* Initialize the compile stack.  */</span>
  compile_stack.<a class="code" href="structcompile__stack__type.html#aebaf05ac308fe465d6a630e5d863fd4a">stack</a> = <a class="code" href="regex_8c.html#aaf77bcbd178f50762a35333d83bacd09">TALLOC</a> (<a class="code" href="regex_8c.html#a988583693c22a092825fc78426d22856">INIT_COMPILE_STACK_SIZE</a>, <a class="code" href="structcompile__stack__elt__t.html">compile_stack_elt_t</a>);
  <span class="keywordflow">if</span> (compile_stack.<a class="code" href="structcompile__stack__type.html#aebaf05ac308fe465d6a630e5d863fd4a">stack</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    <span class="keywordflow">return</span> <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaabf0128b7050c81c0fb933ea7265ebe9">REG_ESPACE</a>;

  compile_stack.<a class="code" href="structcompile__stack__type.html#af5a43e711b027026ed61228f5c96ea71">size</a> = <a class="code" href="regex_8c.html#a988583693c22a092825fc78426d22856">INIT_COMPILE_STACK_SIZE</a>;
  compile_stack.<a class="code" href="structcompile__stack__type.html#a45982ffa38800f8a9502da9708ec587c">avail</a> = 0;

  <span class="comment">/* Initialize the pattern buffer.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#aa16e95a1befa7d5fd8eb89542fa065f8">syntax</a> = syntax;
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a837b026312b860e5485da6240b10d8f7">fastmap_accurate</a> = 0;
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a4a5d480a0891afbab92cf486a04e4a68">not_bol</a> = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a875954f4e64b585471f67b334d33799c">not_eol</a> = 0;

  <span class="comment">/* Set `used&#39; to zero, so that if we return an error, the pattern</span>
<span class="comment">     printer (for debugging) will think there&#39;s no pattern.  We reset it</span>
<span class="comment">     at the end.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a> = 0;

  <span class="comment">/* Always count groups, whether or not bufp-&gt;no_sub is set.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a703c2069a09bac7fa67de8871cb17d35">re_nsub</a> = 0;

<span class="preprocessor">#if !defined emacs &amp;&amp; !defined SYNTAX_TABLE</span>
<span class="preprocessor"></span>  <span class="comment">/* Initialize the syntax table.  */</span>
   <a class="code" href="regex_8c.html#a74a93df5c6415ecc4c83d7497bb52a9b">init_syntax_once</a> ();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a2947439f970297ce6f4a439867c0b5c7">allocated</a> == 0)
    {
      <span class="keywordflow">if</span> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>)
    { <span class="comment">/* If zero allocated, but buffer is non-null, try to realloc</span>
<span class="comment">             enough space.  This loses if buffer&#39;s address is bogus, but</span>
<span class="comment">             that is the user&#39;s responsibility.  */</span>
          <a class="code" href="regex_8c.html#ae247cb248fa0309737dce6bdfc3a6a3d">RETALLOC</a> (bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>, <a class="code" href="regex_8c.html#a598285922e2b62b38ee46ced0ebd9388">INIT_BUF_SIZE</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
        }
      <span class="keywordflow">else</span>
        { <span class="comment">/* Caller did not allocate a buffer.  Do it for them.  */</span>
          bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> = <a class="code" href="regex_8c.html#aaf77bcbd178f50762a35333d83bacd09">TALLOC</a> (<a class="code" href="regex_8c.html#a598285922e2b62b38ee46ced0ebd9388">INIT_BUF_SIZE</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
        }
      <span class="keywordflow">if</span> (!bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaabf0128b7050c81c0fb933ea7265ebe9">REG_ESPACE</a>);

      bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a2947439f970297ce6f4a439867c0b5c7">allocated</a> = <a class="code" href="regex_8c.html#a598285922e2b62b38ee46ced0ebd9388">INIT_BUF_SIZE</a>;
    }

  begalt = b = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>;

  <span class="comment">/* Loop through the uncompiled pattern until we&#39;re at the end.  */</span>
  <span class="keywordflow">while</span> (p != pend)
    {
      <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);

      <span class="keywordflow">switch</span> (c)
        {
        <span class="keywordflow">case</span> <span class="charliteral">&#39;^&#39;</span>:
          {
            <span class="keywordflow">if</span> (   <span class="comment">/* If at start of pattern, it&#39;s an operator.  */</span>
                   p == pattern + 1
                   <span class="comment">/* If context independent, it&#39;s an operator.  */</span>
                || syntax &amp; <a class="code" href="regex-gnu_8h.html#a544bf7770a00eaaa62374a00fea08a2d">RE_CONTEXT_INDEP_ANCHORS</a>
                   <span class="comment">/* Otherwise, depends on what&#39;s come before.  */</span>
                || <a class="code" href="regex_8c.html#a9fcec6851521f04076e51adfa274403c">at_begline_loc_p</a> (pattern, p, syntax))
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4780b4642f63093c414b1833e2d40107">begline</a>);
            <span class="keywordflow">else</span>
              <span class="keywordflow">goto</span> normal_char;
          }
          <span class="keywordflow">break</span>;


        <span class="keywordflow">case</span> <span class="charliteral">&#39;$&#39;</span>:
          {
            <span class="keywordflow">if</span> (   <span class="comment">/* If at end of pattern, it&#39;s an operator.  */</span>
                   p == pend
                   <span class="comment">/* If context independent, it&#39;s an operator.  */</span>
                || syntax &amp; <a class="code" href="regex-gnu_8h.html#a544bf7770a00eaaa62374a00fea08a2d">RE_CONTEXT_INDEP_ANCHORS</a>
                   <span class="comment">/* Otherwise, depends on what&#39;s next.  */</span>
                || <a class="code" href="regex_8c.html#a85a9d04db18bdf4b65ea1113400613e4">at_endline_loc_p</a> (p, pend, syntax))
               <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0556771866997767489c4da274f15aa4">endline</a>);
             <span class="keywordflow">else</span>
               <span class="keywordflow">goto</span> normal_char;
           }
           <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>:
        <span class="keywordflow">case</span> <span class="charliteral">&#39;?&#39;</span>:
          <span class="keywordflow">if</span> ((syntax &amp; <a class="code" href="regex-gnu_8h.html#a94bdc20e1e83b401d2725902a642aa1e">RE_BK_PLUS_QM</a>)
              || (syntax &amp; <a class="code" href="regex-gnu_8h.html#a0782bb31ad7160085c33f13dca7e369f">RE_LIMITED_OPS</a>))
            <span class="keywordflow">goto</span> normal_char;
        handle_plus:
        <span class="keywordflow">case</span> <span class="charliteral">&#39;*&#39;</span>:
          <span class="comment">/* If there is no previous pattern... */</span>
          <span class="keywordflow">if</span> (!laststart)
            {
              <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#ae344a4e6129c8d549a88cd5f45e86adb">RE_CONTEXT_INVALID_OPS</a>)
                <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaf6eaf32c5250906aa304d801a227ccf9">REG_BADRPT</a>);
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(syntax &amp; <a class="code" href="regex-gnu_8h.html#aa96ee57fb2be85936dbb14f2b4c44b50">RE_CONTEXT_INDEP_OPS</a>))
                <span class="keywordflow">goto</span> normal_char;
            }

          {
            <span class="comment">/* Are we optimizing this jump?  */</span>
            <span class="keywordtype">boolean</span> keep_string_p = <span class="keyword">false</span>;

            <span class="comment">/* 1 means zero (many) matches is allowed.  */</span>
            <span class="keywordtype">char</span> zero_times_ok = 0, many_times_ok = 0;

            <span class="comment">/* If there is a sequence of repetition chars, collapse it</span>
<span class="comment">               down to just one (the right one).  We can&#39;t combine</span>
<span class="comment">               interval operators with these because of, e.g., `a{2}*&#39;,</span>
<span class="comment">               which should only match an even number of `a&#39;s.  */</span>

            <span class="keywordflow">for</span> (;;)
              {
                zero_times_ok |= c != <span class="charliteral">&#39;+&#39;</span>;
                many_times_ok |= c != <span class="charliteral">&#39;?&#39;</span>;

                <span class="keywordflow">if</span> (p == pend)
                  <span class="keywordflow">break</span>;

                <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);

                <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;*&#39;</span>
                    || (!(syntax &amp; RE_BK_PLUS_QM) &amp;&amp; (c == <span class="charliteral">&#39;+&#39;</span> || c == <span class="charliteral">&#39;?&#39;</span>)))
                  ;

                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (syntax &amp; RE_BK_PLUS_QM  &amp;&amp;  c == <span class="charliteral">&#39;\\&#39;</span>)
                  {
                    <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeabbae03a00b1f2359894b7fa4ad7efe83">REG_EESCAPE</a>);

                    <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c1);
                    <span class="keywordflow">if</span> (!(c1 == <span class="charliteral">&#39;+&#39;</span> || c1 == <span class="charliteral">&#39;?&#39;</span>))
                      {
                        <a class="code" href="regex_8c.html#a77ae0460c3885ddc73f4544ef494e402">PATUNFETCH</a>;
                        <a class="code" href="regex_8c.html#a77ae0460c3885ddc73f4544ef494e402">PATUNFETCH</a>;
                        <span class="keywordflow">break</span>;
                      }

                    c = c1;
                  }
                <span class="keywordflow">else</span>
                  {
                    <a class="code" href="regex_8c.html#a77ae0460c3885ddc73f4544ef494e402">PATUNFETCH</a>;
                    <span class="keywordflow">break</span>;
                  }

                <span class="comment">/* If we get here, we found another repeat character.  */</span>
               }

            <span class="comment">/* Star, etc. applied to an empty pattern is equivalent</span>
<span class="comment">               to an empty pattern.  */</span>
            <span class="keywordflow">if</span> (!laststart)
              <span class="keywordflow">break</span>;

            <span class="comment">/* Now we know whether or not zero matches is allowed</span>
<span class="comment">               and also whether or not two or more matches is allowed.  */</span>
            <span class="keywordflow">if</span> (many_times_ok)
              { <span class="comment">/* More than one repetition is allowed, so put in at the</span>
<span class="comment">                   end a backward relative jump from `b&#39; to before the next</span>
<span class="comment">                   jump we&#39;re going to put in below (which jumps from</span>
<span class="comment">                   laststart to after this jump).</span>
<span class="comment"></span>
<span class="comment">                   But if we are at the `*&#39; in the exact sequence `.*\n&#39;,</span>
<span class="comment">                   insert an unconditional jump backwards to the .,</span>
<span class="comment">                   instead of the beginning of the loop.  This way we only</span>
<span class="comment">                   push a failure point once, instead of every time</span>
<span class="comment">                   through the loop.  */</span>
                <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (p - 1 &gt; pattern);

                <span class="comment">/* Allocate the space for the jump.  */</span>
                <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (3);

                <span class="comment">/* We know we are not at the first character of the pattern,</span>
<span class="comment">                   because laststart was nonzero.  And we&#39;ve already</span>
<span class="comment">                   incremented `p&#39;, by the way, to be the character after</span>
<span class="comment">                   the `*&#39;.  Do we have to do something analogous here</span>
<span class="comment">                   for null bytes, because of RE_DOT_NOT_NULL?  */</span>
                <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (*(p - 2)) == <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (<span class="charliteral">&#39;.&#39;</span>)
            &amp;&amp; zero_times_ok
                    &amp;&amp; p &lt; pend &amp;&amp; <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (*p) == <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (<span class="charliteral">&#39;\n&#39;</span>)
                    &amp;&amp; !(syntax &amp; <a class="code" href="regex-gnu_8h.html#a405fe43871f2df60407b3c8272f4624c">RE_DOT_NEWLINE</a>))
                  { <span class="comment">/* We have .*\n.  */</span>
                    <a class="code" href="regex_8c.html#acfebc9fd667ce5b7d2162f2677087e21">STORE_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>, b, laststart);
                    keep_string_p = <span class="keyword">true</span>;
                  }
                <span class="keywordflow">else</span>
                  <span class="comment">/* Anything else.  */</span>
                  <a class="code" href="regex_8c.html#acfebc9fd667ce5b7d2162f2677087e21">STORE_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a54819e2968ab91bf6ad492f131d7f37b">maybe_pop_jump</a>, b, laststart - 3);

                <span class="comment">/* We&#39;ve added more stuff to the buffer.  */</span>
                b += 3;
              }

            <span class="comment">/* On failure, jump from laststart to b + 3, which will be the</span>
<span class="comment">               end of the buffer after this jump is inserted.  */</span>
            <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (3);
            <a class="code" href="regex_8c.html#a4c4a6f3c88794d7c99809e8ef5054614">INSERT_JUMP</a> (keep_string_p ? <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118adbebd35172fa7358845d6dd61727883b">on_failure_keep_string_jump</a>
                                       : <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>,
                         laststart, b + 3);
            pending_exact = 0;
            b += 3;

            <span class="keywordflow">if</span> (!zero_times_ok)
              {
                <span class="comment">/* At least one repetition is required, so insert a</span>
<span class="comment">                   `dummy_failure_jump&#39; before the initial</span>
<span class="comment">                   `on_failure_jump&#39; instruction of the loop. This</span>
<span class="comment">                   effects a skip over that instruction the first time</span>
<span class="comment">                   we hit that loop.  */</span>
                <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (3);
                <a class="code" href="regex_8c.html#a4c4a6f3c88794d7c99809e8ef5054614">INSERT_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a3918fb85c0fd4b2f8c84afad14836eba">dummy_failure_jump</a>, laststart, laststart + 6);
                b += 3;
              }
            }
      <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <span class="charliteral">&#39;.&#39;</span>:
          laststart = b;
          <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a375d40bb404dcb4aedbb775f40e7f648">anychar</a>);
          <span class="keywordflow">break</span>;


        <span class="keywordflow">case</span> <span class="charliteral">&#39;[&#39;</span>:
          {
            <span class="keywordtype">boolean</span> had_char_class = <span class="keyword">false</span>;

            <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea88ca33166ecb752a908d3a28f2150123">REG_EBRACK</a>);

            <span class="comment">/* Ensure that we have enough space to push a charset: the</span>
<span class="comment">               opcode, the length count, and the bitset; 34 bytes in all.  */</span>
        <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (34);

            laststart = b;

            <span class="comment">/* We test `*p == &#39;^&#39; twice, instead of using an if</span>
<span class="comment">               statement, so we only need one BUF_PUSH.  */</span>
            <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (*p == <span class="charliteral">&#39;^&#39;</span> ? <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a> : <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6247a0132ac9bb1af7dbc840afe09c88">charset</a>);
            <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;^&#39;</span>)
              p++;

            <span class="comment">/* Remember the first position in the bracket expression.  */</span>
            p1 = <a class="code" href="spgrid_8c.html#a931bc2aa940ac2a4d1601cf842336926">p</a>;

            <span class="comment">/* Push the number of bytes in the bitmap.  */</span>
            <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> ((1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>) / <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>);

            <span class="comment">/* Clear the whole map.  */</span>
            memset (b, 0, (1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>) / <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>);

            <span class="comment">/* charset_not matches newline according to a syntax bit.  */</span>
            <span class="keywordflow">if</span> ((<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>) b[-2] == <a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118abcbe9b8a81da1098e4ffbb7c4f4a8e2e">charset_not</a>
                &amp;&amp; (syntax &amp; <a class="code" href="regex-gnu_8h.html#aad6ec0e3f8f0bb3c53213e3f9ca77d8e">RE_HAT_LISTS_NOT_NEWLINE</a>))
              <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (<span class="charliteral">&#39;\n&#39;</span>);

            <span class="comment">/* Read in characters and ranges, setting map bits.  */</span>
            <span class="keywordflow">for</span> (;;)
              {
                <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea88ca33166ecb752a908d3a28f2150123">REG_EBRACK</a>);

                <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);

                <span class="comment">/* \ might escape characters inside [...] and [^...].  */</span>
                <span class="keywordflow">if</span> ((syntax &amp; <a class="code" href="regex-gnu_8h.html#a45356e84c34c98ed125ea5f75814ccc5">RE_BACKSLASH_ESCAPE_IN_LISTS</a>) &amp;&amp; c == <span class="charliteral">&#39;\\&#39;</span>)
                  {
                    <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeabbae03a00b1f2359894b7fa4ad7efe83">REG_EESCAPE</a>);

                    <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c1);
                    <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (c1);
                    <span class="keywordflow">continue</span>;
                  }

                <span class="comment">/* Could be the end of the bracket expression.  If it&#39;s</span>
<span class="comment">                   not (i.e., when the bracket expression is `[]&#39; so</span>
<span class="comment">                   far), the &#39;]&#39; character bit gets set way below.  */</span>
                <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; p != p1 + 1)
                  <span class="keywordflow">break</span>;

                <span class="comment">/* Look ahead to see if it&#39;s a range when the last thing</span>
<span class="comment">                   was a character class.  */</span>
                <span class="keywordflow">if</span> (had_char_class &amp;&amp; c == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; *p != <span class="charliteral">&#39;]&#39;</span>)
                  <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea16489a654c428b506103ccc746adda00">REG_ERANGE</a>);

                <span class="comment">/* Look ahead to see if it&#39;s a range when the last thing</span>
<span class="comment">                   was a character: if this is a hyphen not at the</span>
<span class="comment">                   beginning or the end of a list, then it&#39;s the range</span>
<span class="comment">                   operator.  */</span>
                <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;-&#39;</span>
                    &amp;&amp; !(p - 2 &gt;= pattern &amp;&amp; p[-2] == <span class="charliteral">&#39;[&#39;</span>)
                    &amp;&amp; !(p - 3 &gt;= pattern &amp;&amp; p[-3] == <span class="charliteral">&#39;[&#39;</span> &amp;&amp; p[-2] == <span class="charliteral">&#39;^&#39;</span>)
                    &amp;&amp; *p != <span class="charliteral">&#39;]&#39;</span>)
                  {
                    <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> ret
                      = <a class="code" href="regex_8c.html#a06b0c1ae265d6791c041df0ddf6d7ff6">compile_range</a> (&amp;p, pend, translate, syntax, b);
                    <span class="keywordflow">if</span> (ret != <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeafa64e5a57596c8c859f982512f52cd6b">REG_NOERROR</a>) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (ret);
                  }

                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; p[1] != <span class="charliteral">&#39;]&#39;</span>)
                  { <span class="comment">/* This handles ranges made up of characters only.  */</span>
                    <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5ae">reg_errcode_t</a> ret;

            <span class="comment">/* Move past the `-&#39;.  */</span>
                    <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c1);

                    ret = <a class="code" href="regex_8c.html#a06b0c1ae265d6791c041df0ddf6d7ff6">compile_range</a> (&amp;p, pend, translate, syntax, b);
                    <span class="keywordflow">if</span> (ret != <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeafa64e5a57596c8c859f982512f52cd6b">REG_NOERROR</a>) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (ret);
                  }

                <span class="comment">/* See if we&#39;re at the beginning of a possible character</span>
<span class="comment">                   class.  */</span>

                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#a9650e76532d0ae7c8cc3ea5eb6dee6e7">RE_CHAR_CLASSES</a> &amp;&amp; c == <span class="charliteral">&#39;[&#39;</span> &amp;&amp; *p == <span class="charliteral">&#39;:&#39;</span>)
                  { <span class="comment">/* Leave room for the null.  */</span>
                    <span class="keywordtype">char</span> <a class="code" href="rip__zebra_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>[<a class="code" href="regex_8c.html#a060354a63e337df065f8cd869b3118f1">CHAR_CLASS_MAX_LENGTH</a> + 1];

                    <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);
                    c1 = 0;

                    <span class="comment">/* If pattern is `[[:&#39;.  */</span>
                    <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea88ca33166ecb752a908d3a28f2150123">REG_EBRACK</a>);

                    <span class="keywordflow">for</span> (;;)
                      {
                        <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);
                        <span class="keywordflow">if</span> ((c == <span class="charliteral">&#39;:&#39;</span> &amp;&amp; *p == <span class="charliteral">&#39;]&#39;</span>) || p == pend)
                          <span class="keywordflow">break</span>;
            <span class="keywordflow">if</span> (c1 &lt; <a class="code" href="regex_8c.html#a060354a63e337df065f8cd869b3118f1">CHAR_CLASS_MAX_LENGTH</a>)
              str[c1++] = c;
            <span class="keywordflow">else</span>
              <span class="comment">/* This is in any case an invalid class name.  */</span>
              str[0] = <span class="charliteral">&#39;\0&#39;</span>;
                      }
                    str[c1] = <span class="charliteral">&#39;\0&#39;</span>;

                    <span class="comment">/* If isn&#39;t a word bracketed by `[:&#39; and `:]&#39;:</span>
<span class="comment">                       undo the ending character, the letters, and leave</span>
<span class="comment">                       the leading `:&#39; and `[&#39; (but set bits for them).  */</span>
                    <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;:&#39;</span> &amp;&amp; *p == <span class="charliteral">&#39;]&#39;</span>)
                      {
<span class="preprocessor">#if defined _LIBC || WIDE_CHAR_SUPPORT</span>
<span class="preprocessor"></span>                        <span class="keywordtype">boolean</span> is_lower = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;lower&quot;</span>);
                        <span class="keywordtype">boolean</span> is_upper = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;upper&quot;</span>);
            wctype_t wt;
                        <span class="keywordtype">int</span> ch;

            wt = <a class="code" href="regex_8c.html#a8b3d83f068b179782bccaca23e3b20f7">IS_CHAR_CLASS</a> (str);
            <span class="keywordflow">if</span> (wt == 0)
              <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea9a04e1101d24afa61896779ff846f837">REG_ECTYPE</a>);

                        <span class="comment">/* Throw away the ] at the end of the character</span>
<span class="comment">                           class.  */</span>
                        <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);

                        <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea88ca33166ecb752a908d3a28f2150123">REG_EBRACK</a>);

                        <span class="keywordflow">for</span> (ch = 0; ch &lt; 1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>; ++ch)
              {
<span class="preprocessor"># ifdef _LIBC</span>
<span class="preprocessor"></span>                <span class="keywordflow">if</span> (__iswctype (__btowc (ch), wt))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
<span class="preprocessor"># else</span>
<span class="preprocessor"></span>                <span class="keywordflow">if</span> (iswctype (btowc (ch), wt))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
<span class="preprocessor"># endif</span>
<span class="preprocessor"></span>
                <span class="keywordflow">if</span> (translate &amp;&amp; (is_upper || is_lower)
                &amp;&amp; (<a class="code" href="regex_8c.html#a2bfd4177f165a5968d95960d42578ab6">ISUPPER</a> (ch) || <a class="code" href="regex_8c.html#acb1e7358e00baea87b36a635fdb6970f">ISLOWER</a> (ch)))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
              }

                        had_char_class = <span class="keyword">true</span>;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                        <span class="keywordtype">int</span> ch;
                        <span class="keywordtype">boolean</span> is_alnum = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;alnum&quot;</span>);
                        <span class="keywordtype">boolean</span> is_alpha = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;alpha&quot;</span>);
                        <span class="keywordtype">boolean</span> is_blank = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;blank&quot;</span>);
                        <span class="keywordtype">boolean</span> is_cntrl = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;cntrl&quot;</span>);
                        <span class="keywordtype">boolean</span> is_digit = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;digit&quot;</span>);
                        <span class="keywordtype">boolean</span> is_graph = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;graph&quot;</span>);
                        <span class="keywordtype">boolean</span> is_lower = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;lower&quot;</span>);
                        <span class="keywordtype">boolean</span> is_print = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;print&quot;</span>);
                        <span class="keywordtype">boolean</span> is_punct = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;punct&quot;</span>);
                        <span class="keywordtype">boolean</span> is_space = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;space&quot;</span>);
                        <span class="keywordtype">boolean</span> is_upper = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;upper&quot;</span>);
                        <span class="keywordtype">boolean</span> is_xdigit = <a class="code" href="regex_8c.html#ab42511b5b7bf70ad31b13c44469d117f">STREQ</a> (str, <span class="stringliteral">&quot;xdigit&quot;</span>);

                        <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a8b3d83f068b179782bccaca23e3b20f7">IS_CHAR_CLASS</a> (str))
              <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea9a04e1101d24afa61896779ff846f837">REG_ECTYPE</a>);

                        <span class="comment">/* Throw away the ] at the end of the character</span>
<span class="comment">                           class.  */</span>
                        <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);

                        <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea88ca33166ecb752a908d3a28f2150123">REG_EBRACK</a>);

                        <span class="keywordflow">for</span> (ch = 0; ch &lt; 1 &lt;&lt; <a class="code" href="regex_8c.html#ad72dc64cd2c9bc3598f792dc518d03b2">BYTEWIDTH</a>; ch++)
                          {
                <span class="comment">/* This was split into 3 if&#39;s to</span>
<span class="comment">                   avoid an arbitrary limit in some compiler.  */</span>
                            <span class="keywordflow">if</span> (   (is_alnum  &amp;&amp; <a class="code" href="regex_8c.html#a8c0056118f585fa052e0f76e3198db6a">ISALNUM</a> (ch))
                                || (is_alpha  &amp;&amp; <a class="code" href="regex_8c.html#afe0bf9496b5e0ecf253fb86072ee7ecf">ISALPHA</a> (ch))
                                || (is_blank  &amp;&amp; <a class="code" href="regex_8c.html#a3773b51bd1f0ba67a1d8f05923c87d4c">ISBLANK</a> (ch))
                                || (is_cntrl  &amp;&amp; <a class="code" href="regex_8c.html#a5079e89f60f6f44944ea9dc3b59f14d5">ISCNTRL</a> (ch)))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
                <span class="keywordflow">if</span> (   (is_digit  &amp;&amp; <a class="code" href="regex_8c.html#ab615ddd0d086b80219cd7e0345d6b5ef">ISDIGIT</a> (ch))
                                || (is_graph  &amp;&amp; <a class="code" href="regex_8c.html#a31ddd189071199427310ccde9cedfb71">ISGRAPH</a> (ch))
                                || (is_lower  &amp;&amp; <a class="code" href="regex_8c.html#acb1e7358e00baea87b36a635fdb6970f">ISLOWER</a> (ch))
                                || (is_print  &amp;&amp; <a class="code" href="regex_8c.html#af65108a54093e5c7220dfc15f6cd9db1">ISPRINT</a> (ch)))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
                <span class="keywordflow">if</span> (   (is_punct  &amp;&amp; <a class="code" href="regex_8c.html#a165393454eb1019f3f77cedba52e23de">ISPUNCT</a> (ch))
                                || (is_space  &amp;&amp; <a class="code" href="regex_8c.html#ae8cdc17e44905c826bddf416b7bf621c">ISSPACE</a> (ch))
                                || (is_upper  &amp;&amp; <a class="code" href="regex_8c.html#a2bfd4177f165a5968d95960d42578ab6">ISUPPER</a> (ch))
                                || (is_xdigit &amp;&amp; <a class="code" href="regex_8c.html#a419f06aab80b7c8eb3aaf4dd70463731">ISXDIGIT</a> (ch)))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
                <span class="keywordflow">if</span> (   translate &amp;&amp; (is_upper || is_lower)
                &amp;&amp; (<a class="code" href="regex_8c.html#a2bfd4177f165a5968d95960d42578ab6">ISUPPER</a> (ch) || <a class="code" href="regex_8c.html#acb1e7358e00baea87b36a635fdb6970f">ISLOWER</a> (ch)))
                  <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (ch);
                          }
                        had_char_class = <span class="keyword">true</span>;
<span class="preprocessor">#endif  </span><span class="comment">/* libc || wctype.h */</span>
                      }
                    <span class="keywordflow">else</span>
                      {
                        c1++;
                        <span class="keywordflow">while</span> (c1--)
                          <a class="code" href="regex_8c.html#a77ae0460c3885ddc73f4544ef494e402">PATUNFETCH</a>;
                        <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (<span class="charliteral">&#39;[&#39;</span>);
                        <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (<span class="charliteral">&#39;:&#39;</span>);
                        had_char_class = <span class="keyword">false</span>;
                      }
                  }
                <span class="keywordflow">else</span>
                  {
                    had_char_class = <span class="keyword">false</span>;
                    <a class="code" href="regex_8c.html#aa09a4c3c61b8d82d7134225bfd5a32f7">SET_LIST_BIT</a> (c);
                  }
              }

            <span class="comment">/* Discard any (non)matching list bytes that are all 0 at the</span>
<span class="comment">               end of the map.  Decrease the map-length byte too.  */</span>
            <span class="keywordflow">while</span> ((<span class="keywordtype">int</span>) b[-1] &gt; 0 &amp;&amp; b[b[-1] - 1] == 0)
              b[-1]--;
            b += b[-1];
          }
          <span class="keywordflow">break</span>;


    <span class="keywordflow">case</span> <span class="charliteral">&#39;(&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#af2f17f18a9c771c91d963f466f559e68">RE_NO_BK_PARENS</a>)
            <span class="keywordflow">goto</span> handle_open;
          <span class="keywordflow">else</span>
            <span class="keywordflow">goto</span> normal_char;


        <span class="keywordflow">case</span> <span class="charliteral">&#39;)&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_BK_PARENS)
            <span class="keywordflow">goto</span> handle_close;
          <span class="keywordflow">else</span>
            <span class="keywordflow">goto</span> normal_char;


        <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#a7a69bf315a61cb9d674332a6a5d64819">RE_NEWLINE_ALT</a>)
            <span class="keywordflow">goto</span> handle_alt;
          <span class="keywordflow">else</span>
            <span class="keywordflow">goto</span> normal_char;


    <span class="keywordflow">case</span> <span class="charliteral">&#39;|&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#a834997e69569c41f0394d6ee120051a0">RE_NO_BK_VBAR</a>)
            <span class="keywordflow">goto</span> handle_alt;
          <span class="keywordflow">else</span>
            <span class="keywordflow">goto</span> normal_char;


        <span class="keywordflow">case</span> <span class="charliteral">&#39;{&#39;</span>:
           <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#a377bd32fc62adedc890f74cd18845aa9">RE_INTERVALS</a> &amp;&amp; syntax &amp; <a class="code" href="regex-gnu_8h.html#a924b9782a779a0db37e3c858967d60af">RE_NO_BK_BRACES</a>)
             <span class="keywordflow">goto</span> handle_interval;
           <span class="keywordflow">else</span>
             <span class="keywordflow">goto</span> normal_char;


        <span class="keywordflow">case</span> <span class="charliteral">&#39;\\&#39;</span>:
          <span class="keywordflow">if</span> (p == pend) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeabbae03a00b1f2359894b7fa4ad7efe83">REG_EESCAPE</a>);

          <span class="comment">/* Do not translate the character after the \, so that we can</span>
<span class="comment">             distinguish, e.g., \B from \b, even if we normally would</span>
<span class="comment">             translate, e.g., B to b.  */</span>
          <a class="code" href="regex_8c.html#a95ed173b1e65d739ab2d15cc9b738ed9">PATFETCH_RAW</a> (c);

          <span class="keywordflow">switch</span> (c)
            {
            <span class="keywordflow">case</span> <span class="charliteral">&#39;(&#39;</span>:
              <span class="keywordflow">if</span> (syntax &amp; RE_NO_BK_PARENS)
                <span class="keywordflow">goto</span> normal_backslash;

            handle_open:
              bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a703c2069a09bac7fa67de8871cb17d35">re_nsub</a>++;
              regnum++;

              <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a7e61c2eafa31a2bc3b4942c22e803e5c">COMPILE_STACK_FULL</a>)
                {
                  <a class="code" href="regex_8c.html#ae247cb248fa0309737dce6bdfc3a6a3d">RETALLOC</a> (compile_stack.<a class="code" href="structcompile__stack__type.html#aebaf05ac308fe465d6a630e5d863fd4a">stack</a>, compile_stack.<a class="code" href="structcompile__stack__type.html#af5a43e711b027026ed61228f5c96ea71">size</a> &lt;&lt; 1,
                            <a class="code" href="structcompile__stack__elt__t.html">compile_stack_elt_t</a>);
                  <span class="keywordflow">if</span> (compile_stack.<a class="code" href="structcompile__stack__type.html#aebaf05ac308fe465d6a630e5d863fd4a">stack</a> == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaabf0128b7050c81c0fb933ea7265ebe9">REG_ESPACE</a>;

                  compile_stack.<a class="code" href="structcompile__stack__type.html#af5a43e711b027026ed61228f5c96ea71">size</a> &lt;&lt;= 1;
                }

              <span class="comment">/* These are the values to restore when we hit end of this</span>
<span class="comment">                 group.  They are all relative offsets, so that if the</span>
<span class="comment">                 whole pattern moves because of realloc, they will still</span>
<span class="comment">                 be valid.  */</span>
              <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.begalt_offset = begalt - bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>;
              <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.fixup_alt_jump
                = fixup_alt_jump ? fixup_alt_jump - bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> + 1 : 0;
              <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.laststart_offset = b - bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>;
              <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.regnum = regnum;

              <span class="comment">/* We will eventually replace the 0 with the number of</span>
<span class="comment">                 groups inner to this one.  But do not push a</span>
<span class="comment">                 start_memory for groups beyond the last one we can</span>
<span class="comment">                 represent in the compiled pattern.  */</span>
              <span class="keywordflow">if</span> (regnum &lt;= <a class="code" href="regex_8c.html#af1b3c3e22fe42152c272df6027b1bf4b">MAX_REGNUM</a>)
                {
                  <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.inner_group_offset = b - bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> + 2;
                  <a class="code" href="regex_8c.html#a38ceed7188d42c689f202512a1cb76fb">BUF_PUSH_3</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118affba14708233f194802bf7981fd7717e">start_memory</a>, regnum, 0);
                }

              compile_stack.<a class="code" href="structcompile__stack__type.html#a45982ffa38800f8a9502da9708ec587c">avail</a>++;

              fixup_alt_jump = 0;
              laststart = 0;
              begalt = b;
          <span class="comment">/* If we&#39;ve reached MAX_REGNUM groups, then this open</span>
<span class="comment">         won&#39;t actually generate any code, so we&#39;ll have to</span>
<span class="comment">         clear pending_exact explicitly.  */</span>
          pending_exact = 0;
              <span class="keywordflow">break</span>;


            <span class="keywordflow">case</span> <span class="charliteral">&#39;)&#39;</span>:
              <span class="keywordflow">if</span> (syntax &amp; RE_NO_BK_PARENS) <span class="keywordflow">goto</span> normal_backslash;

              <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a7d96976a27d0138b3f189f1d1a663d68">COMPILE_STACK_EMPTY</a>)
        {
          <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#af1907a994cab6bd73ad14677b126a64b">RE_UNMATCHED_RIGHT_PAREN_ORD</a>)
            <span class="keywordflow">goto</span> normal_backslash;
          <span class="keywordflow">else</span>
            <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea5797541a6619c4a5dbe28fe3bb58661b">REG_ERPAREN</a>);
        }

            handle_close:
              <span class="keywordflow">if</span> (fixup_alt_jump)
                { <span class="comment">/* Push a dummy failure point at the end of the</span>
<span class="comment">                     alternative for a possible future</span>
<span class="comment">                     `pop_failure_jump&#39; to pop.  See comments at</span>
<span class="comment">                     `push_dummy_failure&#39; in `re_match_2&#39;.  */</span>
                  <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae96f67086c4f61cc6fd32b6b493dc17f">push_dummy_failure</a>);

                  <span class="comment">/* We allocated space for this jump when we assigned</span>
<span class="comment">                     to `fixup_alt_jump&#39;, in the `handle_alt&#39; case below.  */</span>
                  <a class="code" href="regex_8c.html#acfebc9fd667ce5b7d2162f2677087e21">STORE_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>, fixup_alt_jump, b - 1);
                }

              <span class="comment">/* See similar code for backslashed left paren above.  */</span>
              <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a7d96976a27d0138b3f189f1d1a663d68">COMPILE_STACK_EMPTY</a>)
        {
          <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#af1907a994cab6bd73ad14677b126a64b">RE_UNMATCHED_RIGHT_PAREN_ORD</a>)
            <span class="keywordflow">goto</span> normal_char;
          <span class="keywordflow">else</span>
            <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea5797541a6619c4a5dbe28fe3bb58661b">REG_ERPAREN</a>);
        }

              <span class="comment">/* Since we just checked for an empty stack above, this</span>
<span class="comment">                 ``can&#39;t happen&#39;&#39;.  */</span>
              <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (compile_stack.<a class="code" href="structcompile__stack__type.html#a45982ffa38800f8a9502da9708ec587c">avail</a> != 0);
              {
                <span class="comment">/* We don&#39;t just want to restore into `regnum&#39;, because</span>
<span class="comment">                   later groups should continue to be numbered higher,</span>
<span class="comment">                   as in `(ab)c(de)&#39; -- the second group is #2.  */</span>
                <a class="code" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a> this_group_regnum;

                compile_stack.<a class="code" href="structcompile__stack__type.html#a45982ffa38800f8a9502da9708ec587c">avail</a>--;
                begalt = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> + <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.begalt_offset;
                fixup_alt_jump
                  = <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.fixup_alt_jump
                    ? bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> + <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.fixup_alt_jump - 1
                    : 0;
                laststart = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> + <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.laststart_offset;
                this_group_regnum = <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.regnum;
        <span class="comment">/* If we&#39;ve reached MAX_REGNUM groups, then this open</span>
<span class="comment">           won&#39;t actually generate any code, so we&#39;ll have to</span>
<span class="comment">           clear pending_exact explicitly.  */</span>
        pending_exact = 0;

                <span class="comment">/* We&#39;re at the end of the group, so now we know how many</span>
<span class="comment">                   groups were inside this one.  */</span>
                <span class="keywordflow">if</span> (this_group_regnum &lt;= <a class="code" href="regex_8c.html#af1b3c3e22fe42152c272df6027b1bf4b">MAX_REGNUM</a>)
                  {
                    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *inner_group_loc
                      = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> + <a class="code" href="regex_8c.html#a3c27bf6437874eb87a6622b75d2dac32">COMPILE_STACK_TOP</a>.inner_group_offset;

                    *inner_group_loc = regnum - this_group_regnum;
                    <a class="code" href="regex_8c.html#a38ceed7188d42c689f202512a1cb76fb">BUF_PUSH_3</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a6a42f30575b66116b79f4527493d0ce9">stop_memory</a>, this_group_regnum,
                                regnum - this_group_regnum);
                  }
              }
              <span class="keywordflow">break</span>;


            <span class="keywordflow">case</span> <span class="charliteral">&#39;|&#39;</span>:                   <span class="comment">/* `\|&#39;.  */</span>
              <span class="keywordflow">if</span> (syntax &amp; RE_LIMITED_OPS || syntax &amp; RE_NO_BK_VBAR)
                <span class="keywordflow">goto</span> normal_backslash;
            handle_alt:
              <span class="keywordflow">if</span> (syntax &amp; RE_LIMITED_OPS)
                <span class="keywordflow">goto</span> normal_char;

              <span class="comment">/* Insert before the previous alternative a jump which</span>
<span class="comment">                 jumps to this alternative if the former fails.  */</span>
              <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (3);
              <a class="code" href="regex_8c.html#a4c4a6f3c88794d7c99809e8ef5054614">INSERT_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5ca3d8a56cc5259243bcaffedd070287">on_failure_jump</a>, begalt, b + 6);
              pending_exact = 0;
              b += 3;

              <span class="comment">/* The alternative before this one has a jump after it</span>
<span class="comment">                 which gets executed if it gets matched.  Adjust that</span>
<span class="comment">                 jump so it will jump to this alternative&#39;s analogous</span>
<span class="comment">                 jump (put in below, which in turn will jump to the next</span>
<span class="comment">                 (if any) alternative&#39;s such jump, etc.).  The last such</span>
<span class="comment">                 jump jumps to the correct final destination.  A picture:</span>
<span class="comment">                          _____ _____</span>
<span class="comment">                          |   | |   |</span>
<span class="comment">                          |   v |   v</span>
<span class="comment">                         a | b   | c</span>
<span class="comment"></span>
<span class="comment">                 If we are at `b&#39;, then fixup_alt_jump right now points to a</span>
<span class="comment">                 three-byte space after `a&#39;.  We&#39;ll put in the jump, set</span>
<span class="comment">                 fixup_alt_jump to right after `b&#39;, and leave behind three</span>
<span class="comment">                 bytes which we&#39;ll fill in when we get to after `c&#39;.  */</span>

              <span class="keywordflow">if</span> (fixup_alt_jump)
                <a class="code" href="regex_8c.html#acfebc9fd667ce5b7d2162f2677087e21">STORE_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>, fixup_alt_jump, b);

              <span class="comment">/* Mark and leave space for a jump after this alternative,</span>
<span class="comment">                 to be filled in later either by next alternative or</span>
<span class="comment">                 when know we&#39;re at the end of a series of alternatives.  */</span>
              fixup_alt_jump = b;
              <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (3);
              b += 3;

              laststart = 0;
              begalt = b;
              <span class="keywordflow">break</span>;


            <span class="keywordflow">case</span> <span class="charliteral">&#39;{&#39;</span>:
              <span class="comment">/* If \{ is a literal.  */</span>
              <span class="keywordflow">if</span> (!(syntax &amp; <a class="code" href="regex-gnu_8h.html#a377bd32fc62adedc890f74cd18845aa9">RE_INTERVALS</a>)
                     <span class="comment">/* If we&#39;re at `\{&#39; and it&#39;s not the open-interval</span>
<span class="comment">                        operator.  */</span>
                  || ((syntax &amp; RE_INTERVALS) &amp;&amp; (syntax &amp; RE_NO_BK_BRACES))
                  || (p - 2 == pattern  &amp;&amp;  p == pend))
                <span class="keywordflow">goto</span> normal_backslash;

            handle_interval:
              {
                <span class="comment">/* If got here, then the syntax allows intervals.  */</span>

                <span class="comment">/* At least (most) this many matches must be made.  */</span>
                <span class="keywordtype">int</span> lower_bound = -1, upper_bound = -1;

                beg_interval = p - 1;

                <span class="keywordflow">if</span> (p == pend)
                  {
                    <span class="keywordflow">if</span> (syntax &amp; RE_NO_BK_BRACES)
                      <span class="keywordflow">goto</span> unfetch_interval;
                    <span class="keywordflow">else</span>
                      <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeafad659d2f7fe4c0f9d360ef68d371673">REG_EBRACE</a>);
                  }

                <a class="code" href="regex_8c.html#aa678aabaa579a244b2f36e8e452d977e">GET_UNSIGNED_NUMBER</a> (lower_bound);

                <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;,&#39;</span>)
                  {
                    <a class="code" href="regex_8c.html#aa678aabaa579a244b2f36e8e452d977e">GET_UNSIGNED_NUMBER</a> (upper_bound);
                    <span class="keywordflow">if</span> (upper_bound &lt; 0) upper_bound = <a class="code" href="regex-gnu_8h.html#aa7d072d0a88c61d3692dc547ea27538e">RE_DUP_MAX</a>;
                  }
                <span class="keywordflow">else</span>
                  <span class="comment">/* Interval such as `{1}&#39; =&gt; match exactly once. */</span>
                  upper_bound = lower_bound;

                <span class="keywordflow">if</span> (lower_bound &lt; 0 || upper_bound &gt; <a class="code" href="regex-gnu_8h.html#aa7d072d0a88c61d3692dc547ea27538e">RE_DUP_MAX</a>
                    || lower_bound &gt; upper_bound)
                  {
                    <span class="keywordflow">if</span> (syntax &amp; RE_NO_BK_BRACES)
                      <span class="keywordflow">goto</span> unfetch_interval;
                    <span class="keywordflow">else</span>
                      <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaeda9cecaba728fe6b18a8537872ffd34">REG_BADBR</a>);
                  }

                <span class="keywordflow">if</span> (!(syntax &amp; RE_NO_BK_BRACES))
                  {
                    <span class="keywordflow">if</span> (c != <span class="charliteral">&#39;\\&#39;</span>) <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeafad659d2f7fe4c0f9d360ef68d371673">REG_EBRACE</a>);

                    <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);
                  }

                <span class="keywordflow">if</span> (c != <span class="charliteral">&#39;}&#39;</span>)
                  {
                    <span class="keywordflow">if</span> (syntax &amp; RE_NO_BK_BRACES)
                      <span class="keywordflow">goto</span> unfetch_interval;
                    <span class="keywordflow">else</span>
                      <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaeda9cecaba728fe6b18a8537872ffd34">REG_BADBR</a>);
                  }

                <span class="comment">/* We just parsed a valid interval.  */</span>

                <span class="comment">/* If it&#39;s invalid to have no preceding re.  */</span>
                <span class="keywordflow">if</span> (!laststart)
                  {
                    <span class="keywordflow">if</span> (syntax &amp; RE_CONTEXT_INVALID_OPS)
                      <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeaf6eaf32c5250906aa304d801a227ccf9">REG_BADRPT</a>);
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#aa96ee57fb2be85936dbb14f2b4c44b50">RE_CONTEXT_INDEP_OPS</a>)
                      laststart = b;
                    <span class="keywordflow">else</span>
                      <span class="keywordflow">goto</span> unfetch_interval;
                  }

                <span class="comment">/* If the upper bound is zero, don&#39;t want to succeed at</span>
<span class="comment">                   all; jump from `laststart&#39; to `b + 3&#39;, which will be</span>
<span class="comment">                   the end of the buffer after we insert the jump.  */</span>
                 <span class="keywordflow">if</span> (upper_bound == 0)
                   {
                     <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (3);
                     <a class="code" href="regex_8c.html#a4c4a6f3c88794d7c99809e8ef5054614">INSERT_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a5a08a3c1fa135350961630d2f9c2b849">jump</a>, laststart, b + 3);
                     b += 3;
                   }

                 <span class="comment">/* Otherwise, we have a nontrivial interval.  When</span>
<span class="comment">                    we&#39;re all done, the pattern will look like:</span>
<span class="comment">                      set_number_at &lt;jump count&gt; &lt;upper bound&gt;</span>
<span class="comment">                      set_number_at &lt;succeed_n count&gt; &lt;lower bound&gt;</span>
<span class="comment">                      succeed_n &lt;after jump addr&gt; &lt;succeed_n count&gt;</span>
<span class="comment">                      &lt;body of loop&gt;</span>
<span class="comment">                      jump_n &lt;succeed_n addr&gt; &lt;jump count&gt;</span>
<span class="comment">                    (The upper bound and `jump_n&#39; are omitted if</span>
<span class="comment">                    `upper_bound&#39; is 1, though.)  */</span>
                 <span class="keywordflow">else</span>
                   { <span class="comment">/* If the upper bound is &gt; 1, we need to insert</span>
<span class="comment">                        more at the end of the loop.  */</span>
                     <span class="keywordtype">unsigned</span> nbytes = 10 + (upper_bound &gt; 1) * 10;

                     <a class="code" href="regex_8c.html#a820795fca6e5960dd9657eda06c66ed5">GET_BUFFER_SPACE</a> (nbytes);

                     <span class="comment">/* Initialize lower bound of the `succeed_n&#39;, even</span>
<span class="comment">                        though it will be set during matching by its</span>
<span class="comment">                        attendant `set_number_at&#39; (inserted next),</span>
<span class="comment">                        because `re_compile_fastmap&#39; needs to know.</span>
<span class="comment">                        Jump to the `jump_n&#39; we might insert below.  */</span>
                     <a class="code" href="regex_8c.html#a7dd59dc7da937c9308d1e7b9331aa916">INSERT_JUMP2</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ae45bee3e6749253a8ba8769646f79734">succeed_n</a>, laststart,
                                   b + 5 + (upper_bound &gt; 1) * 5,
                                   lower_bound);
                     b += 5;

                     <span class="comment">/* Code to initialize the lower bound.  Insert</span>
<span class="comment">                        before the `succeed_n&#39;.  The `5&#39; is the last two</span>
<span class="comment">                        bytes of this `set_number_at&#39;, plus 3 bytes of</span>
<span class="comment">                        the following `succeed_n&#39;.  */</span>
                     <a class="code" href="regex_8c.html#ae31b1d009dfa3a2b5eca3f11ec3dee6a">insert_op2</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>, laststart, 5, lower_bound, b);
                     b += 5;

                     <span class="keywordflow">if</span> (upper_bound &gt; 1)
                       { <span class="comment">/* More than one repetition is allowed, so</span>
<span class="comment">                            append a backward jump to the `succeed_n&#39;</span>
<span class="comment">                            that starts this interval.</span>
<span class="comment"></span>
<span class="comment">                            When we&#39;ve reached this during matching,</span>
<span class="comment">                            we&#39;ll have matched the interval once, so</span>
<span class="comment">                            jump back only `upper_bound - 1&#39; times.  */</span>
                         <a class="code" href="regex_8c.html#aa2aa60706e57e51cc9b54ff2c8cc38a2">STORE_JUMP2</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a333721a24859c29322c8abdae4159e1b">jump_n</a>, b, laststart + 5,
                                      upper_bound - 1);
                         b += 5;

                         <span class="comment">/* The location we want to set is the second</span>
<span class="comment">                            parameter of the `jump_n&#39;; that is `b-2&#39; as</span>
<span class="comment">                            an absolute address.  `laststart&#39; will be</span>
<span class="comment">                            the `set_number_at&#39; we&#39;re about to insert;</span>
<span class="comment">                            `laststart+3&#39; the number to set, the source</span>
<span class="comment">                            for the relative address.  But we are</span>
<span class="comment">                            inserting into the middle of the pattern --</span>
<span class="comment">                            so everything is getting moved up by 5.</span>
<span class="comment">                            Conclusion: (b - 2) - (laststart + 3) + 5,</span>
<span class="comment">                            i.e., b - laststart.</span>
<span class="comment"></span>
<span class="comment">                            We insert this at the beginning of the loop</span>
<span class="comment">                            so that if we fail during matching, we&#39;ll</span>
<span class="comment">                            reinitialize the bounds.  */</span>
                         <a class="code" href="regex_8c.html#ae31b1d009dfa3a2b5eca3f11ec3dee6a">insert_op2</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0f280efb7129538f3b07aa789fc99fa1">set_number_at</a>, laststart, b - laststart,
                                     upper_bound - 1, b);
                         b += 5;
                       }
                   }
                pending_exact = 0;
                beg_interval = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
              }
              <span class="keywordflow">break</span>;

            unfetch_interval:
              <span class="comment">/* If an invalid interval, match the characters as literals.  */</span>
               <a class="code" href="regex_8c.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert</a> (beg_interval);
               p = beg_interval;
               beg_interval = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;

               <span class="comment">/* normal_char and normal_backslash need `c&#39;.  */</span>
               <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);

               <span class="keywordflow">if</span> (!(syntax &amp; RE_NO_BK_BRACES))
                 {
                   <span class="keywordflow">if</span> (p &gt; pattern  &amp;&amp;  p[-1] == <span class="charliteral">&#39;\\&#39;</span>)
                     <span class="keywordflow">goto</span> normal_backslash;
                 }
               <span class="keywordflow">goto</span> normal_char;

<span class="preprocessor">#ifdef emacs</span>
<span class="preprocessor"></span>            <span class="comment">/* There is no way to specify the before_dot and after_dot</span>
<span class="comment">               operators.  rms says this is ok.  --karl  */</span>
            <span class="keywordflow">case</span> <span class="charliteral">&#39;=&#39;</span>:
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (at_dot);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>:
              laststart = b;
              <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);
              <a class="code" href="regex_8c.html#a8cfee99226a6b73952701f9de12912b9">BUF_PUSH_2</a> (syntaxspec, syntax_spec_code[c]);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;S&#39;</span>:
              laststart = b;
              <a class="code" href="regex_8c.html#a557d2f1c16f9bd2123e55885ee447c06">PATFETCH</a> (c);
              <a class="code" href="regex_8c.html#a8cfee99226a6b73952701f9de12912b9">BUF_PUSH_2</a> (notsyntaxspec, syntax_spec_code[c]);
              <span class="keywordflow">break</span>;
<span class="preprocessor">#endif </span><span class="comment">/* emacs */</span>


            <span class="keywordflow">case</span> <span class="charliteral">&#39;w&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#af60fbd1f693bfb95fd0a80caae9aa4c5">RE_NO_GNU_OPS</a>)
        <span class="keywordflow">goto</span> normal_char;
              laststart = b;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a26eed2ae578da61bebc7b55e7610cf0b">wordchar</a>);
              <span class="keywordflow">break</span>;


            <span class="keywordflow">case</span> <span class="charliteral">&#39;W&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              laststart = b;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a01398d7bcfdbcb84b318fc65a7ef9c93">notwordchar</a>);
              <span class="keywordflow">break</span>;


            <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ad88e0028985b6bc61df64cd9578d3f18">wordbeg</a>);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118accd3c02d3bd48af753cf5261bfb084ac">wordend</a>);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;b&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a47168d753b8d555d2e89416a4b660da9">wordbound</a>);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;B&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a9077999caa8f316015aabfd83b3745a0">notwordbound</a>);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;`&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab428f43b6557e8dfc45e452a8891b598">begbuf</a>);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;\&#39;&#39;</span>:
          <span class="keywordflow">if</span> (syntax &amp; RE_NO_GNU_OPS)
        <span class="keywordflow">goto</span> normal_char;
              <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a4962434097279c747aa6ba59df478775">endbuf</a>);
              <span class="keywordflow">break</span>;

            <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;2&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;3&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;4&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;5&#39;</span>:
            <span class="keywordflow">case</span> <span class="charliteral">&#39;6&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;7&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;8&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;9&#39;</span>:
              <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#aed01be95fde1250190b37b7788af5f35">RE_NO_BK_REFS</a>)
                <span class="keywordflow">goto</span> normal_char;

              c1 = c - <span class="charliteral">&#39;0&#39;</span>;

              <span class="keywordflow">if</span> (c1 &gt; regnum)
                <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeac700e4cae84ffc418afdff14792abf34">REG_ESUBREG</a>);

              <span class="comment">/* Can&#39;t back reference to a subexpression if inside of it.  */</span>
              <span class="keywordflow">if</span> (<a class="code" href="regex_8c.html#a28dc5088ce179431d47162481e6c6540">group_in_compile_stack</a> (compile_stack, (<a class="code" href="regex_8c.html#a9e5a8ee5ece120e8e7b7c28eea3aa7cd">regnum_t</a>) c1))
                <span class="keywordflow">goto</span> normal_char;

              laststart = b;
              <a class="code" href="regex_8c.html#a8cfee99226a6b73952701f9de12912b9">BUF_PUSH_2</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a0c02fe9db75630f52c6e9e44dd55d9de">duplicate</a>, c1);
              <span class="keywordflow">break</span>;


            <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>:
            <span class="keywordflow">case</span> <span class="charliteral">&#39;?&#39;</span>:
              <span class="keywordflow">if</span> (syntax &amp; RE_BK_PLUS_QM)
                <span class="keywordflow">goto</span> handle_plus;
              <span class="keywordflow">else</span>
                <span class="keywordflow">goto</span> normal_backslash;

            <span class="keywordflow">default</span>:
            normal_backslash:
              <span class="comment">/* You might think it would be useful for \ to mean</span>
<span class="comment">                 not to translate; but if we don&#39;t translate it</span>
<span class="comment">                 it will never match anything.  */</span>
              c = <a class="code" href="regex_8c.html#a2eeeb49b77aa0f299d2d3c23dc1bfa17">TRANSLATE</a> (c);
              <span class="keywordflow">goto</span> normal_char;
            }
          <span class="keywordflow">break</span>;


    <span class="keywordflow">default</span>:
        <span class="comment">/* Expects the character in `c&#39;.  */</span>
    normal_char:
          <span class="comment">/* If no exactn currently being built.  */</span>
          <span class="keywordflow">if</span> (!pending_exact

              <span class="comment">/* If last exactn not at current position.  */</span>
              || pending_exact + *pending_exact + 1 != b

              <span class="comment">/* We have only one byte following the exactn for the count.  */</span>
          || *pending_exact == (1 &lt;&lt; BYTEWIDTH) - 1

              <span class="comment">/* If followed by a repetition operator.  */</span>
              || *p == <span class="charliteral">&#39;*&#39;</span> || *p == <span class="charliteral">&#39;^&#39;</span>
          || ((syntax &amp; RE_BK_PLUS_QM)
          ? *p == <span class="charliteral">&#39;\\&#39;</span> &amp;&amp; (p[1] == <span class="charliteral">&#39;+&#39;</span> || p[1] == <span class="charliteral">&#39;?&#39;</span>)
          : (*p == <span class="charliteral">&#39;+&#39;</span> || *p == <span class="charliteral">&#39;?&#39;</span>))
          || ((syntax &amp; RE_INTERVALS)
                  &amp;&amp; ((syntax &amp; RE_NO_BK_BRACES)
              ? *p == <span class="charliteral">&#39;{&#39;</span>
                      : (p[0] == <span class="charliteral">&#39;\\&#39;</span> &amp;&amp; p[1] == <span class="charliteral">&#39;{&#39;</span>))))
        {
          <span class="comment">/* Start building a new exactn.  */</span>

              laststart = b;

          <a class="code" href="regex_8c.html#a8cfee99226a6b73952701f9de12912b9">BUF_PUSH_2</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118ab0eca0e160953a14bcb41d151287d1f1">exactn</a>, 0);
          pending_exact = b - 1;
            }

      <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (c);
          (*pending_exact)++;
      <span class="keywordflow">break</span>;
        } <span class="comment">/* switch (c) */</span>
    } <span class="comment">/* while p != pend */</span>


  <span class="comment">/* Through the pattern now.  */</span>

  <span class="keywordflow">if</span> (fixup_alt_jump)
    <a class="code" href="regex_8c.html#acfebc9fd667ce5b7d2162f2677087e21">STORE_JUMP</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a2b75b8e92a52c848de16544d9ceb08da">jump_past_alt</a>, fixup_alt_jump, b);

  <span class="keywordflow">if</span> (!<a class="code" href="regex_8c.html#a7d96976a27d0138b3f189f1d1a663d68">COMPILE_STACK_EMPTY</a>)
    <a class="code" href="regex_8c.html#a90d3a551feb495f25eaf3e22933dd1d7">FREE_STACK_RETURN</a> (<a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aeabde1462e3a1660e121d79ce2d0cc5664">REG_EPAREN</a>);

  <span class="comment">/* If we don&#39;t want backtracking, force success</span>
<span class="comment">     the first time we reach the end of the compiled pattern.  */</span>
  <span class="keywordflow">if</span> (syntax &amp; <a class="code" href="regex-gnu_8h.html#a35cf160909ead17ad6599238a2ebdd58">RE_NO_POSIX_BACKTRACKING</a>)
    <a class="code" href="regex_8c.html#aef73eb530578e61ff012a68faccb18d0">BUF_PUSH</a> (<a class="code" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118a37fe3367d5bf38cb0ac666ebae52d4f9">succeed</a>);

  free (compile_stack.<a class="code" href="structcompile__stack__type.html#aebaf05ac308fe465d6a630e5d863fd4a">stack</a>);

  <span class="comment">/* We have succeeded; set the length of the buffer.  */</span>
  bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a> = b - bufp-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>;

<span class="preprocessor">#ifdef DEBUG</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="bgp__debug_8c.html#abc1624539747635021518178e4df5a69">debug</a>)
    {
      <a class="code" href="regex_8c.html#a90a312923984a45f83767acea95b84a1">DEBUG_PRINT1</a> (<span class="stringliteral">&quot;\nCompiled pattern: \n&quot;</span>);
      print_compiled_pattern (bufp);
    }
<span class="preprocessor">#endif </span><span class="comment">/* DEBUG */</span>

<span class="preprocessor">#ifndef MATCH_MAY_ALLOCATE</span>
<span class="preprocessor"></span>  <span class="comment">/* Initialize the failure stack to the largest possible stack.  This</span>
<span class="comment">     isn&#39;t necessary unless we&#39;re trying to avoid calling alloca in</span>
<span class="comment">     the search and match routines.  */</span>
  {
    <span class="keywordtype">int</span> num_regs = bufp-&gt;<a class="code" href="structre__pattern__buffer.html#a703c2069a09bac7fa67de8871cb17d35">re_nsub</a> + 1;

    <span class="comment">/* Since DOUBLE_FAIL_STACK refuses to double only if the current size</span>
<span class="comment">       is strictly greater than re_max_failures, the largest possible stack</span>
<span class="comment">       is 2 * re_max_failures failure points.  */</span>
    <span class="keywordflow">if</span> (fail_stack.size &lt; (2 * <a class="code" href="regex_8c.html#a22b8c11c82d877fbf919376da65e62ca">re_max_failures</a> * <a class="code" href="regex_8c.html#a9c1cb14ecb36be1c3ff3c5a050ecc561">MAX_FAILURE_ITEMS</a>))
      {
    fail_stack.size = (2 * <a class="code" href="regex_8c.html#a22b8c11c82d877fbf919376da65e62ca">re_max_failures</a> * <a class="code" href="regex_8c.html#a9c1cb14ecb36be1c3ff3c5a050ecc561">MAX_FAILURE_ITEMS</a>);

<span class="preprocessor"># ifdef emacs</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (! fail_stack.stack)
      fail_stack.stack
        = (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *) xmalloc (fail_stack.size
                        * sizeof (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a>));
    <span class="keywordflow">else</span>
      fail_stack.stack
        = (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *) xrealloc (fail_stack.stack,
                         (fail_stack.size
                          * sizeof (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a>)));
<span class="preprocessor"># else </span><span class="comment">/* not emacs */</span>
    <span class="keywordflow">if</span> (! fail_stack.stack)
      fail_stack.stack
        = (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *) <a class="code" href="regex_8c.html#ab7e36af3707843f77cc5b4e831c2fa6d">malloc</a> (fail_stack.size
                       * sizeof (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a>));
    <span class="keywordflow">else</span>
      fail_stack.stack
        = (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a> *) <a class="code" href="regex_8c.html#a3d4d6185d412b00bc3def2b58b2898cc">realloc</a> (fail_stack.stack,
                        (fail_stack.size
                         * sizeof (<a class="code" href="unionfail__stack__elt.html">fail_stack_elt_t</a>)));
<span class="preprocessor"># endif </span><span class="comment">/* not emacs */</span>
      }

    regex_grow_registers (num_regs);
</pre></div>
</div>
</div>
<a class="anchor" id="a0298f60fae70832d70e8ec5d032472a8"></a><!-- doxytag: member="regex.c::regexec" ref="a0298f60fae70832d70e8ec5d032472a8" args="(regex_t *preg, const char *string, size_t nmatch, pmatch, int eflags) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regexec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *&#160;</td>
          <td class="paramname"><em>preg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pmatch&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05753">5753</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> ret;
  <span class="keyword">struct </span><a class="code" href="structre__registers.html">re_registers</a> regs;
  <a class="code" href="structre__pattern__buffer.html">regex_t</a> private_preg;
  <span class="keywordtype">int</span> len = strlen (<span class="keywordtype">string</span>);
  <span class="keywordtype">boolean</span> want_reg_info = !preg-&gt;<a class="code" href="structre__pattern__buffer.html#a83e122c96edb258aa4ef99d7a8b2bfa2">no_sub</a> &amp;&amp; nmatch &gt; 0;

  private_preg = *preg;

  private_preg.<a class="code" href="structre__pattern__buffer.html#a4a5d480a0891afbab92cf486a04e4a68">not_bol</a> = !!(eflags &amp; <a class="code" href="regex-gnu_8h.html#aa0ca15a79530976f6d4ef90326c46858">REG_NOTBOL</a>);
  private_preg.not_eol = !!(eflags &amp; <a class="code" href="regex-gnu_8h.html#a9d97d85ef86123060a845723d28a92cb">REG_NOTEOL</a>);

  <span class="comment">/* The user has told us exactly how many registers to return</span>
<span class="comment">     information about, via `nmatch&#39;.  We have to pass that on to the</span>
<span class="comment">     matching routines.  */</span>
  private_preg.regs_allocated = <a class="code" href="regex-gnu_8h.html#a54c8820fca418980dbcd43ebd78ed5a6">REGS_FIXED</a>;

  <span class="keywordflow">if</span> (want_reg_info)
    {
      regs.num_regs = nmatch;
      regs.start = <a class="code" href="regex_8c.html#aaf77bcbd178f50762a35333d83bacd09">TALLOC</a> (nmatch * 2, <a class="code" href="regex-gnu_8h.html#a5b34995b47432512ee4ffa32b836e65f">regoff_t</a>);
      <span class="keywordflow">if</span> (regs.start == <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
        <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) <a class="code" href="regex-gnu_8h.html#a1a37133027e6fa3a5f31044f9a76c5aea4cc3b232a9ce92df5523d8c464c7beb2">REG_NOMATCH</a>;
      regs.end = regs.start + nmatch;
    }

  <span class="comment">/* Perform the searching operation.  */</span>
  ret = <a class="code" href="regex_8c.html#afe0743116f59f62a4d00f50a9e9a4932">re_search</a> (&amp;private_preg, <span class="keywordtype">string</span>, len,
                   <span class="comment">/* start: */</span> 0, <span class="comment">/* range: */</span> len,
                   want_reg_info ? &amp;regs : (<span class="keyword">struct</span> <a class="code" href="structre__registers.html">re_registers</a> *) 0);

  <span class="comment">/* Copy the register information to the POSIX structure.  */</span>
  <span class="keywordflow">if</span> (want_reg_info)
    {
      <span class="keywordflow">if</span> (ret &gt;= 0)
        {
          <span class="keywordtype">unsigned</span> r;

          <span class="keywordflow">for</span> (r = 0; r &lt; nmatch; r++)
            {
              pmatch[r].rm_so = regs.start[r];
              pmatch[r].rm_eo = regs.end[r];
            }
        }

      <span class="comment">/* If we needed the temporary register info, free the space now.  */</span>
      free (regs.start);
</pre></div>
</div>
</div>
<a class="anchor" id="ad94d0de532eaa4fd959b8adde4d64898"></a><!-- doxytag: member="regex.c::regfree" ref="ad94d0de532eaa4fd959b8adde4d64898" args="(regex_t *preg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regfree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex-gnu_8h.html#a159f97bcead74ee31a0817571f7625a9">regex_t</a> *&#160;</td>
          <td class="paramname"><em>preg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l05867">5867</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (preg-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> != <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    free (preg-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a>);
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#ae60c7055854785bf6e2743fd314fcb83">buffer</a> = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;

  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a2947439f970297ce6f4a439867c0b5c7">allocated</a> = 0;
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a5c6bb086f4bfebee8aa4373c03bcc74b">used</a> = 0;

  <span class="keywordflow">if</span> (preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a> != <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
    free (preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a>);
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a103ac216c8fd6a8734daa4999fca3efb">fastmap</a> = <a class="code" href="regex_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
  preg-&gt;<a class="code" href="structre__pattern__buffer.html#a837b026312b860e5485da6240b10d8f7">fastmap_accurate</a> = 0;
</pre></div>
</div>
</div>
<a class="anchor" id="ac119126b68c58a7c0fc1af5b119450ed"></a><!-- doxytag: member="regex.c::store_op1" ref="ac119126b68c58a7c0fc1af5b119450ed" args="(re_opcode_t op, unsigned char *loc, int arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void store_op1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l02995">2995</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="ab2200093505d6435c2521ff819125d0d"></a><!-- doxytag: member="regex.c::store_op2" ref="ab2200093505d6435c2521ff819125d0d" args="(re_opcode_t op, unsigned char *loc, int arg1, int arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void store_op2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="regex_8c.html#ad1f757f0a86665780f50f812767b2118">re_opcode_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l03008">3008</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a4a5e7ab240e155127f898d0a96c68922"></a><!-- doxytag: member="regex.c::re_error_msgid" ref="a4a5e7ab240e155127f898d0a96c68922" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="regex_8c.html#a4a5e7ab240e155127f898d0a96c68922">re_error_msgid</a>[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01020">1020</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aff41b1a2e0447b7f5744746b3abb9530"></a><!-- doxytag: member="regex.c::re_error_msgid_idx" ref="aff41b1a2e0447b7f5744746b3abb9530" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="regex_8c.html#aff41b1a2e0447b7f5744746b3abb9530">re_error_msgid_idx</a>[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
  {
    <a class="code" href="regex_8c.html#a53cac93056e7e4dcd77c87fd5b64ab85">REG_NOERROR_IDX</a>,
    <a class="code" href="regex_8c.html#a20c488a0672699e12eebb87f4536a2a1">REG_NOMATCH_IDX</a>,
    <a class="code" href="regex_8c.html#a48ae85c8247f711c7612edf7783e857c">REG_BADPAT_IDX</a>,
    <a class="code" href="regex_8c.html#a6c414c00809d9b700e9d8071c4d8b051">REG_ECOLLATE_IDX</a>,
    <a class="code" href="regex_8c.html#acdb862b0439091c6aba1ddb34ec74c9f">REG_ECTYPE_IDX</a>,
    <a class="code" href="regex_8c.html#a94bc4724ebb8f838d053f9f10fa3981a">REG_EESCAPE_IDX</a>,
    <a class="code" href="regex_8c.html#aacadf8be59807dfbb1e55d08c26744b9">REG_ESUBREG_IDX</a>,
    <a class="code" href="regex_8c.html#a206525485bf45f18ebf8fd0fcab5f3cd">REG_EBRACK_IDX</a>,
    <a class="code" href="regex_8c.html#ab27649935fb8e05dd687d0d1e738697a">REG_EPAREN_IDX</a>,
    <a class="code" href="regex_8c.html#ae63f97c2af9852820b09ada8117982f3">REG_EBRACE_IDX</a>,
    <a class="code" href="regex_8c.html#a4d53631524c3e1f51d75b3d50f04d8ed">REG_BADBR_IDX</a>,
    <a class="code" href="regex_8c.html#a9335e944484ecf3dac6270666feaaf1f">REG_ERANGE_IDX</a>,
    <a class="code" href="regex_8c.html#af6d28ac4aa08afd5fe52f7fd43abc5bb">REG_ESPACE_IDX</a>,
    <a class="code" href="regex_8c.html#acf4d9e47a0ca86890be7bee5fc73aceb">REG_BADRPT_IDX</a>,
    <a class="code" href="regex_8c.html#a5f5131e9e883c6f787f7c1041d3d3f1a">REG_EEND_IDX</a>,
    <a class="code" href="regex_8c.html#aa86dc74b96a36fc455d490601cab5529">REG_ESIZE_IDX</a>,
    <a class="code" href="regex_8c.html#a7a212c67e65cef62a14bc026104b3965">REG_ERPAREN_IDX</a>
  }
</pre></div>
<p>Definition at line <a class="el" href="regex_8c_source.html#l01074">1074</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a22b8c11c82d877fbf919376da65e62ca"></a><!-- doxytag: member="regex.c::re_max_failures" ref="a22b8c11c82d877fbf919376da65e62ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="regex_8c.html#a22b8c11c82d877fbf919376da65e62ca">re_max_failures</a> = 20000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01180">1180</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="abdc5e67bbb6a48b740a95aef2bc3f5f2"></a><!-- doxytag: member="regex.c::re_syntax_options" ref="abdc5e67bbb6a48b740a95aef2bc3f5f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="regex-gnu_8h.html#a7e0565199a2fabaca3d67a5a44fc4229">reg_syntax_t</a> <a class="el" href="regex_8c.html#abdc5e67bbb6a48b740a95aef2bc3f5f2">re_syntax_options</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00986">986</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="a87944e3ae2c8e13e58ae2209e27447a8"></a><!-- doxytag: member="regex.c::re_syntax_table" ref="a87944e3ae2c8e13e58ae2209e27447a8" args="[CHAR_SET_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="regex_8c.html#a87944e3ae2c8e13e58ae2209e27447a8">re_syntax_table</a>[CHAR_SET_SIZE]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l00180">180</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
<a class="anchor" id="aadf22463a9896cf91277d88f89246e43"></a><!-- doxytag: member="regex.c::reg_unset_dummy" ref="aadf22463a9896cf91277d88f89246e43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="regex_8c.html#aadf22463a9896cf91277d88f89246e43">reg_unset_dummy</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="regex_8c_source.html#l01550">1550</a> of file <a class="el" href="regex_8c_source.html">regex.c</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="regex_8c.html">regex.c</a>      </li>

    <li class="footer">Generated on Tue Apr 24 2012 10:41:24 for OSPFN by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
